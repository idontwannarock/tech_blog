<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>docker on Howard Tech Note</title>
    <link>https://blog.idontwannarock.me/tags/docker/</link>
    <description>Recent content in docker on Howard Tech Note</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This website by Howard Wang is licensed under a Creative Common Attribution-ShareAlike 4.0 International License.</copyright>
    <lastBuildDate>Thu, 15 Dec 2022 10:18:10 +0800</lastBuildDate><atom:link href="https://blog.idontwannarock.me/tags/docker/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Gradle &#43; Docker Multi-stage build</title>
      <link>https://blog.idontwannarock.me/2022/12/gradle_docker_multi_stage_build/</link>
      <pubDate>Thu, 15 Dec 2022 10:18:10 +0800</pubDate>
      
      <guid>https://blog.idontwannarock.me/2022/12/gradle_docker_multi_stage_build/</guid>
      <description>Java 專案整合 Docker multi-stage build 系列：
Maven + Docker Multi-stage build Gradle + Docker Multi-stage build 前一篇講過 Maven 配合 Docker multi-stage build 的優化概念跟實作，這篇順便來講一下 Gradle 的部分
Docker Multi-stage Build 前一篇已經介紹過建置 Java 專案配合 Docker multi-stage build 的優化概念，這邊就不再贅述，直接上 Dockerfile：
FROM gradle:7.6-alpine AS Cache WORKDIR /opt/app ENV GRADLE_USER_HOME /cache COPY build.gradle ./ RUN gradle --no-daemon dependencies --stacktrace FROM gradle:7.6-jdk11-alpine AS Builder WORKDIR /opt/app COPY --from=Cache /cache /home/gradle/.gradle COPY build.gradle settings.gradle ./ COPY src /opt/app/src RUN gradle --no-daemon build --stacktrace --offline FROM azul/zulu-openjdk-alpine:11-jre-headless WORKDIR /opt/app COPY --from=Builder /opt/app/build/libs/*.</description>
    </item>
    
    <item>
      <title>Maven &#43; Docker Multi-stage Build</title>
      <link>https://blog.idontwannarock.me/2022/12/maven_docker_multi_stage_build/</link>
      <pubDate>Wed, 14 Dec 2022 14:14:44 +0800</pubDate>
      
      <guid>https://blog.idontwannarock.me/2022/12/maven_docker_multi_stage_build/</guid>
      <description>Java 專案整合 Docker multi-stage build 系列：
Maven + Docker Multi-stage build Gradle + Docker Multi-stage build 現代常見的 CI/CD 流程經常會使用容器化 (containerized) 的方式來幫助建置環境及部署
以 Java + Maven 專案舉例，一個比較通用的 Dockerfile 可能長這樣：
FROM maven:3.8-openjdk-11 WORKDIR /opt/app COPY src/main/resources /opt/app/src/main/resources COPY src/main/java /opt/app/src/main/java COPY pom.xml . RUN mvn -B -e clean package EXPOSE 8080 ENTRYPOINT [&amp;#34;java&amp;#34;, &amp;#34;-jar&amp;#34;, &amp;#34;demo.jar&amp;#34;] 這個 Dockerfile 其實沒有問題，完全可以正常運行，但它使用上有一個地方不太方便，就是每次運行到 RUN mvn -B -e clean package 這行的時候，除非程式碼跟 pom.xml 都沒有變動，否則所有 dependencies 都會重新下載一遍，如果專案比較大型，那光下載 dependencies 可能就會要花很久的時間
Docker Multi-stage Build 於是就有人使出了 Docker multi-stage build 這招</description>
    </item>
    
  </channel>
</rss>
