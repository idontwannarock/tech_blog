<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Spring-Security on Howard Tech Note</title>
    <link>https://blog.idontwannarock.dev/tags/spring-security/</link>
    <description>Recent content in Spring-Security on Howard Tech Note</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <copyright>This website by Howard Wang is licensed under a Creative Common Attribution-ShareAlike 4.0 International License.</copyright>
    <lastBuildDate>Tue, 01 Nov 2022 15:28:32 +0800</lastBuildDate>
    <atom:link href="https://blog.idontwannarock.dev/tags/spring-security/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Spring Boot 後端實作 XSS 防範</title>
      <link>https://blog.idontwannarock.dev/2022/11/xss_prevention_spring_boot/</link>
      <pubDate>Tue, 01 Nov 2022 15:28:32 +0800</pubDate>
      <guid>https://blog.idontwannarock.dev/2022/11/xss_prevention_spring_boot/</guid>
      <description>&lt;p&gt;XSS 系列：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://blog.idontwannarock.dev/2022/11/xss_prevention_intro/&#34;&gt;XSS 防範簡介&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;Spring Boot 後端實作 XSS 防範&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;身為一個 Java 後端工程師，今天要來討論如何在 Spring Boot 的後端專案進行 general 的 XSS 防範。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;請還是注意，general 的手段並不能很良好的防範 XSS 攻擊，而只是提供一個基本程度的防範。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;csp-header&#34;&gt;CSP Header&lt;/h2&gt;&#xA;&lt;p&gt;如果專案有整合 Spring Security，Spring Security 原生就已經預設在 response header 中加入 &lt;code&gt;X-XSS-Protection: 1; mode=block&lt;/code&gt;，但因為 CSP 需要自行設定資源允許的來源，所以 Spring Security 並沒有預設，需要在 &lt;code&gt;SecurityFilterChain&lt;/code&gt; 當中設定，舉例如下：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;@Bean&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;SecurityFilterChain &lt;span style=&#34;color:#50fa7b&#34;&gt;filterChain&lt;/span&gt;(HttpSecurity httpSecurity) &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;throws&lt;/span&gt; Exception {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  httpSecurity.&lt;span style=&#34;color:#50fa7b&#34;&gt;headers&lt;/span&gt;().&lt;span style=&#34;color:#50fa7b&#34;&gt;contentSecurityPolicy&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;script-src &amp;#39;self&amp;#39;&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ...&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如此就會在 response header 中加入 &lt;code&gt;Content-Security-Policy: script-src &#39;self&#39;&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;h2 id=&#34;output-encoding&#34;&gt;Output Encoding&lt;/h2&gt;&#xA;&lt;p&gt;再來，後端也可以對接收到或回傳的資料做 escape，例如採取將內容都做 escape，將符號都轉換成 HTML Entities 的方式。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Spring Boot 實作 API 版本控制</title>
      <link>https://blog.idontwannarock.dev/2019/09/spring_api_version_with_swagger_security/</link>
      <pubDate>Thu, 19 Sep 2019 15:53:36 +0800</pubDate>
      <guid>https://blog.idontwannarock.dev/2019/09/spring_api_version_with_swagger_security/</guid>
      <description>&lt;p&gt;本文目的是為了探討在 Spring Boot Web 專案中，實作 API 版本控制，並兼容 Swagger 及 Spring Security 的解決方式&lt;/p&gt;&#xA;&lt;p&gt;需要有 Spring Boot、Spring MVC、Spring Security 及 Swagger 的基礎概念會比較好理解&lt;/p&gt;&#xA;&lt;h1 id=&#34;api-版本控制&#34;&gt;API 版本控制&lt;/h1&gt;&#xA;&lt;p&gt;常見的 API 版本控制方式有三種: URI, header, content-type&lt;/p&gt;&#xA;&lt;p&gt;考量到 RESTful API 其中的一個好處是方便快取，使用 header 跟 content-type 的方式則可能無法正確的快取以及達成 idempotent，所以我個人採用的是在 URI 中加入版本號的方式&lt;/p&gt;&#xA;&lt;p&gt;再來因為有時候面對的專案有數量眾多的 handler，導致每次修改版本號都要手動修改每一支 handler 對應的 uri，這樣既麻煩又不潮，所以一定要研究一下怎麼在 Spring Boot 專案中利用註解的方式自動幫 handler 對應的 uri 自動插入版本號&lt;/p&gt;&#xA;&lt;h1 id=&#34;tech-stack&#34;&gt;Tech Stack&lt;/h1&gt;&#xA;&lt;p&gt;專案採用的是 Spring Boot 2.0 架構，Java 1.8 版本&lt;/p&gt;&#xA;&lt;p&gt;有關 Maven 依賴如下:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;org.springframework.boot:spring-boot-starter-web:2.1.x&lt;/li&gt;&#xA;&lt;li&gt;org.springframework.boot:spring-boot-starter-security:2.1.x&lt;/li&gt;&#xA;&lt;li&gt;io.springfox:springfox-swagger2:2.9.2&lt;/li&gt;&#xA;&lt;li&gt;io.springfox:springfox-swagger-ui:2.9.2&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;這邊強調要採用 Spring Boot 主要是因為想要利用 Spring Boot auto configuration 的功能，也因為想要利用這個功能，所以過程才會這麼曲折&amp;hellip;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Spring Security 整合 RBAC</title>
      <link>https://blog.idontwannarock.dev/2019/05/spring_security_rbac/</link>
      <pubDate>Thu, 30 May 2019 15:33:07 +0800</pubDate>
      <guid>https://blog.idontwannarock.dev/2019/05/spring_security_rbac/</guid>
      <description>&lt;p&gt;目前比較主流的 &lt;a href=&#34;https://en.wikipedia.org/wiki/Role-based_access_control&#34;&gt;Role-based Access Control, RBAC&lt;/a&gt; 算是比較成熟且彈性的權限架構，若要在 Spring Security 實作 RBAC 並搭配 JWT 或 OAuth 2.0，大概要探討兩個問題&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;是否值得為了減少查詢資料源的次數，而將角色或權限直接置入 JWT 或 Authorization Server 回傳的 token&lt;/li&gt;&#xA;&lt;li&gt;是否採取 Spring Security 原生只使用最細粒度的權限來進行存取控制&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;關於第一個問題，目前的思考點大概就是考量系統的併發度跟使用者總數&lt;/p&gt;&#xA;&lt;p&gt;如果需要高併發，那自然希望盡量減少查詢資料的次數或資料量，盡量避免同時大量消耗 DB 資源；相反的，如果不需要高併發，那每次驗證都重新取得角色及權限資料也沒關係&lt;/p&gt;&#xA;&lt;p&gt;使用者數量的考量也是類似，如果每次查詢的成本太高，則盡量減少查詢的次數&lt;/p&gt;&#xA;&lt;p&gt;而第二個問題，則是要考量實際的業務場景&lt;/p&gt;&#xA;&lt;p&gt;如果角色跟權限很大量且複雜，或可能要考慮角色分層甚至使用者群組，或不同 Domain 有不同的權限邏輯，則可能用 Spring Security 原生方式會不敷使用，相對如果角色權限結構簡單，則直接使用原生方式可能成本較低&lt;/p&gt;&#xA;&lt;p&gt;所以以下探討主要專注於使用 Spring Security 提供的自訂空間來實作較為複雜的存取控制&lt;/p&gt;&#xA;&lt;h1 id=&#34;spring-security-權限架構&#34;&gt;Spring Security 權限架構&lt;/h1&gt;&#xA;&lt;p&gt;首先要探討 Spring Security 原生提供的權限架構&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;GrantedAuthority: 可以將每個 GrantedAuthority 想成是個別的 privilege，所以在 Spring Security 中，authority 就是 privilege 的概念&lt;/li&gt;&#xA;&lt;li&gt;Role: 在 Spring Security 中為了保持彈性，Role 可以當作 Authority 也可以當作一組 Authority 的組合&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Role as Authority: 直接把 Role 當成一種 Authority 的情況，就是將 Role 當作一個有 ROLE_ 前綴的字串，這種情況下 Role 跟 Authority 就只是語意上的差別&lt;/li&gt;&#xA;&lt;li&gt;Role as Container: Role 可以包含一組 Authority，Spring Security 在這個概念上沒有提供太多指引說明，需要自行實作&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.baeldung.com/spring-security-granted-authority-vs-role&#34;&gt;Granted Authority Versus Role in Spring Security&lt;/a&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
