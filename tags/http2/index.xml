<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Http2 on Howard Tech Note</title>
    <link>https://blog.idontwannarock.me/tags/http2/</link>
    <description>Recent content in Http2 on Howard Tech Note</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <copyright>This website by Howard Wang is licensed under a Creative Common Attribution-ShareAlike 4.0 International License.</copyright>
    <lastBuildDate>Mon, 27 Dec 2021 09:44:31 +0800</lastBuildDate>
    <atom:link href="https://blog.idontwannarock.me/tags/http2/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>gRPC 概念</title>
      <link>https://blog.idontwannarock.me/2021/12/grpc/</link>
      <pubDate>Mon, 27 Dec 2021 09:44:31 +0800</pubDate>
      <guid>https://blog.idontwannarock.me/2021/12/grpc/</guid>
      <description>&lt;p&gt;在前幾篇大略了解 HTTP/2 的概念後，就可以來了解 gRPC 的運作概念了&lt;/p&gt;&#xA;&lt;p&gt;HTTP/2 系列:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://blog.idontwannarock.me/2021/12/http2/&#34;&gt;HTTP/2 系列 - HTTP/2 概念&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://blog.idontwannarock.me/2021/12/http_server_push/&#34;&gt;HTTP/2 系列 - HTTP Server Push 技術&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;概念&#34;&gt;概念&lt;/h2&gt;&#xA;&lt;p&gt;gRPC 原本是 Google 內部的 RPC 系統，後來開源後，近年成為很熱門的 RPC 系統，採用 HTTP/2 做傳輸，ProtoBuf 作為介面描述語言 (interface description language)，提供身分驗證 (authentication)、雙向串流 (bidirectional streaming)、流量控制 (flow control)、阻塞或非阻塞綁定 (blocking or nonblocking binding)、取消 (cancellation) 及逾時 (timeouts) 等特性&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;RPC Remote Procedure Call 遠端程序呼叫指服務之間互相溝通就如同呼叫本地程式一般，不須關注呼叫互動的細節。例如以前的 CORBA, Java RMI 等&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;使用-grpc-api&#34;&gt;使用 gRPC API&lt;/h3&gt;&#xA;&lt;p&gt;主要是透過 .proto 檔定義 service 結構，再透過 ProtoBuf compiler 的幫助產生各語言的 client/server 端代碼&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;client 端會有一個本地物件 stub 實作 service 中相同的方法，讓 client 端可以直接呼叫該本地物件的方法，gRPC 會處理發出 request 以及從 server 端的 ProtoBuf response&lt;/li&gt;&#xA;&lt;li&gt;server 端會真正實作 service 中宣告的方法，並運行 gRPC server 來處理 client 端的呼叫，gRPC infra 會將 request 解碼，執行 service 方法，再將 service response 編碼&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dcvgho2zc/image/upload/c_scale,h_304/v1640339739/Tech%20Blog/grpc-call.png&#34; alt=&#34;gRPC 呼叫關係&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>HTTP/2 系列 - HTTP Server Push 技術</title>
      <link>https://blog.idontwannarock.me/2021/12/http_server_push/</link>
      <pubDate>Fri, 24 Dec 2021 15:49:27 +0800</pubDate>
      <guid>https://blog.idontwannarock.me/2021/12/http_server_push/</guid>
      <description>&lt;p&gt;這篇預計是 HTTP/2 系列的最後一篇，之前在系列前面已經釐清了 HTTP/2 的概念了，其中我比較有興趣的就是 HTTP/2 的 server push 新特性，這邊就繼續來了解一下吧~&lt;/p&gt;&#xA;&lt;p&gt;HTTP/2 系列:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://blog.idontwannarock.me/2021/12/http2/&#34;&gt;HTTP/2 系列 - HTTP/2 概念&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;HTTP/2 系列 - HTTP Server Push 技術&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;http-server-push-技術&#34;&gt;HTTP Server Push 技術&lt;/h2&gt;&#xA;&lt;p&gt;首先來探討一下有哪些基於 HTTP 協定的 server push 技術&lt;/p&gt;&#xA;&lt;p&gt;相對於 request-response 模型必須要一端發出 request 後另一端再對應的發出 response，server push 一般是指不經 client 端發出指定的 request 就由 server 端發出 message 給 client 端&lt;/p&gt;&#xA;&lt;p&gt;這種技術在某些情況是很有用的，像是需要「即時」更新資料的應用場景，例如比賽分數，當然這可以在 client 端採用定時輪詢 (polling) 的方式來實作，但這樣其實對於 client 端或 server 端都會造成資源的浪費，因為可能大多數請求實際上都沒有需要更新的資料，實際上知道資料有變動的就是 server 端，如果可以由 server 端在資料真正有變動的時候主動通知 client 端，就可以將資料元的浪費降到最低&lt;/p&gt;&#xA;&lt;p&gt;也因為在許多需要「即時」的情況下由 server 端主動通知 client 端都可以節省大量效能浪費，所以才會一直都有追求 server push 技術的需求存在&lt;/p&gt;</description>
    </item>
    <item>
      <title>HTTP/2 系列 - HTTP/2 概念</title>
      <link>https://blog.idontwannarock.me/2021/12/http2/</link>
      <pubDate>Tue, 21 Dec 2021 09:06:29 +0800</pubDate>
      <guid>https://blog.idontwannarock.me/2021/12/http2/</guid>
      <description>&lt;p&gt;從 2015 年 RFC 7540 正式發表後，至今 HTTP/2 已經被絕大多數主流瀏覽器所支援，並且是正當紅的 gRPC 的基礎，在研究 gPRC 之前，先來釐清一下 HTTP/2 的概念&lt;/p&gt;&#xA;&lt;p&gt;這篇是 HTTP/2 系列文章的第一篇:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;HTTP/2 系列 - HTTP/2 概念&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://blog.idontwannarock.me/2021/12/http_server_push/&#34;&gt;HTTP/2 系列 - HTTP Server Push 技術&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;不過，我其實只想研究我想研究的部分，所以不見得會把 HTTP/2 所有相關的內容都研究一遍&lt;/p&gt;&#xA;&lt;h2 id=&#34;從遠古-http10-開始&#34;&gt;從遠古 HTTP/1.0 開始&lt;/h2&gt;&#xA;&lt;p&gt;HTTP 是定義在 OSI 模型第七層 Application Layer 網路協議，HTTP/1.0 採取先進先出 (first-in first-out, FIFO) 策略，每次請求/回應都是有序的，必須等到請求收到對應回應後，才能進行下一次請求&lt;/p&gt;&#xA;&lt;p&gt;HTTP 在 Transport Layer 採用 TCP 連線來通訊，而 TCP 要在 client/server 之間建立連線，是靠著三向交握 (three-way handshake) 來完成；而傳輸完成要斷線時則要做四次握手 (four-way handshake)。如果還有 TLS，那握手的來回通訊次數 (round-trip time, RTT) 就更多次了&lt;/p&gt;&#xA;&lt;p&gt;而在最初的 HTTP/1.0 的年代，硬體普遍效能都不高，為了提高系統的效率，所以 HTTP/1.0 規定 client/server 只能保持短暫的連線，所以 client 每次請求最少都要經過三向交握建立 TCP 連線，而 server 完成該請求的處理後也必須立刻進行四次握手斷開連線&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
