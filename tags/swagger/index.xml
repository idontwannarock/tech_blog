<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Swagger on Howard Tech Note</title>
    <link>https://blog.idontwannarock.dev/tags/swagger/</link>
    <description>Recent content in Swagger on Howard Tech Note</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <copyright>This website by Howard Wang is licensed under a Creative Common Attribution-ShareAlike 4.0 International License.</copyright>
    <lastBuildDate>Mon, 12 Dec 2022 09:24:17 +0800</lastBuildDate>
    <atom:link href="https://blog.idontwannarock.dev/tags/swagger/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>SpringFox to SpringDoc</title>
      <link>https://blog.idontwannarock.dev/2022/12/springfox_to_springdoc/</link>
      <pubDate>Mon, 12 Dec 2022 09:24:17 +0800</pubDate>
      <guid>https://blog.idontwannarock.dev/2022/12/springfox_to_springdoc/</guid>
      <description>&lt;p&gt;以 Spring Boot 生態來說，比較主流的 documentation 方式應該就是 Swagger，以往應該多數人都是使用 SpringFox library，但近幾年也漸漸興起使用 SpringDoc，所以就做了一點筆記，紀錄要怎麼從 SpringFox 轉移到 SpringDoc&lt;/p&gt;&#xA;&lt;h1 id=&#34;比較&#34;&gt;比較&lt;/h1&gt;&#xA;&lt;p&gt;這兩者同樣都有實作 OpenAPI 3.0，為什麼我們需要從 SpringFox 轉移使用 SpringDoc？&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;springfox-boot-starter&lt;/code&gt; 包含許多 Spring 的 transitive dependencies；&lt;code&gt;springdoc-openapi-ui&lt;/code&gt; 則是 standalone 的 library，並沒有跟 Spring 的依賴&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;springfox-boot-starter&lt;/code&gt; 需要額外 dependency 才有 Swagger UI 的呈現；&lt;code&gt;springdoc-openapi-ui&lt;/code&gt; 則已經內含 Swagger UI&lt;/li&gt;&#xA;&lt;li&gt;SpringDoc 在一些細節功能上更強大，例如提供陣列參數更好的 UI 做輸入&lt;/li&gt;&#xA;&lt;li&gt;最重要的一點，SpringFox 幾乎已經不再更新；而 SpringDoc 還有在常態維護，因此也能跟較新版本的 Spring 有更好的整合，也能更即時的修正 bug&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;升級步驟&#34;&gt;升級步驟&lt;/h1&gt;&#xA;&lt;p&gt;相當簡單，參考 &lt;a href=&#34;https://springdoc.org/#migrating-from-springfox&#34;&gt;官方文件&lt;/a&gt; 即可&lt;/p&gt;&#xA;&lt;p&gt;因為都是實作 OpenAPI，就算 SpringFox 有實作 2.0 版，但跟 3.0 其實差異也不大&lt;/p&gt;&#xA;&lt;p&gt;主要就是改一下 dependency，然後 annotation 調整一下，其他幾乎沒有不同&lt;/p&gt;&#xA;&lt;h1 id=&#34;注意事項&#34;&gt;注意事項&lt;/h1&gt;&#xA;&lt;h2 id=&#34;spring-security&#34;&gt;Spring Security&lt;/h2&gt;&#xA;&lt;p&gt;若有整合 Spring Security，則可以在 controller 透過加註 &lt;code&gt;@AuthenticationPrincipal&lt;/code&gt; 註解注入驗證過的 principal 物件，但這個物件不需要呈現在 Swagger 上&lt;/p&gt;</description>
    </item>
    <item>
      <title>Spring Boot 實作 API 版本控制</title>
      <link>https://blog.idontwannarock.dev/2019/09/spring_api_version_with_swagger_security/</link>
      <pubDate>Thu, 19 Sep 2019 15:53:36 +0800</pubDate>
      <guid>https://blog.idontwannarock.dev/2019/09/spring_api_version_with_swagger_security/</guid>
      <description>&lt;p&gt;本文目的是為了探討在 Spring Boot Web 專案中，實作 API 版本控制，並兼容 Swagger 及 Spring Security 的解決方式&lt;/p&gt;&#xA;&lt;p&gt;需要有 Spring Boot、Spring MVC、Spring Security 及 Swagger 的基礎概念會比較好理解&lt;/p&gt;&#xA;&lt;h1 id=&#34;api-版本控制&#34;&gt;API 版本控制&lt;/h1&gt;&#xA;&lt;p&gt;常見的 API 版本控制方式有三種: URI, header, content-type&lt;/p&gt;&#xA;&lt;p&gt;考量到 RESTful API 其中的一個好處是方便快取，使用 header 跟 content-type 的方式則可能無法正確的快取以及達成 idempotent，所以我個人採用的是在 URI 中加入版本號的方式&lt;/p&gt;&#xA;&lt;p&gt;再來因為有時候面對的專案有數量眾多的 handler，導致每次修改版本號都要手動修改每一支 handler 對應的 uri，這樣既麻煩又不潮，所以一定要研究一下怎麼在 Spring Boot 專案中利用註解的方式自動幫 handler 對應的 uri 自動插入版本號&lt;/p&gt;&#xA;&lt;h1 id=&#34;tech-stack&#34;&gt;Tech Stack&lt;/h1&gt;&#xA;&lt;p&gt;專案採用的是 Spring Boot 2.0 架構，Java 1.8 版本&lt;/p&gt;&#xA;&lt;p&gt;有關 Maven 依賴如下:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;org.springframework.boot:spring-boot-starter-web:2.1.x&lt;/li&gt;&#xA;&lt;li&gt;org.springframework.boot:spring-boot-starter-security:2.1.x&lt;/li&gt;&#xA;&lt;li&gt;io.springfox:springfox-swagger2:2.9.2&lt;/li&gt;&#xA;&lt;li&gt;io.springfox:springfox-swagger-ui:2.9.2&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;這邊強調要採用 Spring Boot 主要是因為想要利用 Spring Boot auto configuration 的功能，也因為想要利用這個功能，所以過程才會這麼曲折&amp;hellip;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
