<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>quartz on Howard Tech Note</title>
    <link>https://blog.idontwannarock.me/tags/quartz/</link>
    <description>Recent content in quartz on Howard Tech Note</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This website by Howard Wang is licensed under a Creative Common Attribution-ShareAlike 4.0 International License.</copyright>
    <lastBuildDate>Tue, 29 Nov 2022 15:21:19 +0800</lastBuildDate><atom:link href="https://blog.idontwannarock.me/tags/quartz/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Quartz Misfire Handling Instruction</title>
      <link>https://blog.idontwannarock.me/2022/11/quartz-misfire-handling-instruction/</link>
      <pubDate>Tue, 29 Nov 2022 15:21:19 +0800</pubDate>
      
      <guid>https://blog.idontwannarock.me/2022/11/quartz-misfire-handling-instruction/</guid>
      <description>Quartz 系列：
Quartz 介紹 Spring Boot 整合 Quartz 集群執行預設及動態排程 Quartz Misfire Handling Instruction 使用 Quartz 來幫助排程管理很方便，但還有一個需要注意的地方，就是設定 misfire handling instruction
Misfire 概念 首先要來釐清在 Quartz 的架構下，什麼情況能稱為 misfire，其實講到底就只有一種：「Job 在到達預定該觸發的時間未觸發」
但怎樣算是未觸發，其實主要有兩個條件，第一個是設定的「觸發時間」，第二個則是「misfireThreshold」
舉例來說如果有一個 Job 設定 12:00 觸發，並且 Quartz 的 misfireThreshold 設定為 2min，因此當我在 12:01 準備要執行的時候，因為已經超過設定的觸發時間，但還沒有超過 misfireThreshold 的 2min，所以並不會被 Quartz 認為是 misfire
那另一方面來說，以同樣的例子而言，如果 Quartz 準備要執行的時候已經是 12:03，那這個 Job 的這次執行就會被認為是 misfire，這時候 Quartz 就會依照設定好的 misfire handling instruction 來執行未觸發時的動作
這樣舉例就能很清楚的理解 misfireThreshold 的意義
要在 Spring Boot 整合 Quartz 專案中設定 misfireThreshold，可在 properties 檔中設定 spring.</description>
    </item>
    
    <item>
      <title>Spring Boot 整合 Quartz 集群執行預設及動態排程</title>
      <link>https://blog.idontwannarock.me/2022/11/quartz-cluster-fixed-and-dynamic-trigger-spring-boot-integration/</link>
      <pubDate>Tue, 15 Nov 2022 16:54:13 +0800</pubDate>
      
      <guid>https://blog.idontwannarock.me/2022/11/quartz-cluster-fixed-and-dynamic-trigger-spring-boot-integration/</guid>
      <description>Quartz 系列：
Quartz 介紹 Spring Boot 整合 Quartz 集群執行預設及動態排程 Quartz Misfire Handling Instruction Spring Boot 官方本身就有 spring-boot-starter-quartz 來提供 Quartz 整合，所以在 Spring Boot 當中使用基本 Quartz 功能已經非常簡單
至於動態產生排程，網路上也很多教學，只是大多是採用 API 呼叫的方式去動態產生、運行、暫停、刪除排程等功能，而幾乎沒看到利用預設排程定時從 database 取得動態排程設定，並動態產生或移除排程的功能
接下來探討如何在 Spring Boot 整合 Quartz 的框架中實作以上需求，來達成依照自訂動態排程來發通知的需求
以下討論採用 Spring Boot 2.7.5 及 Quartz 2.3.2 版本並搭配 MySQL 做持久化
Database Schema 首先需要在 MySQL 內建立相關的 schema，可以利用官方提供的這個 script 來建立，並額外依照以下 sql 建立動態通知排程的 table：
create table if not exist NOTIFICATION_SCHEDULE ( ID int auto_increment primary key, CRON varchar(100) not null comment &amp;#39;Quartz type cron&amp;#39;, TIMEZONE varchar(64) default &amp;#39;Asia/Taipei&amp;#39; null, TEMPLATE_ID int not null, IS_ONLINE tinyint(1) default 1 null, IS_DELETED tinyint(1) default 0 null, CREATE_TIME datetime default CURRENT_TIMESTAMP null, UPDATE_TIME datetime null on update CURRENT_TIMESTAMP ) comment &amp;#39;紀錄通知排程資訊&amp;#39;; Dependency 接著在 pom 檔引用以下依賴：</description>
    </item>
    
    <item>
      <title>Quartz 介紹</title>
      <link>https://blog.idontwannarock.me/2022/11/quartz-intro/</link>
      <pubDate>Tue, 15 Nov 2022 16:24:46 +0800</pubDate>
      
      <guid>https://blog.idontwannarock.me/2022/11/quartz-intro/</guid>
      <description>Quartz 系列：
Quartz 介紹 Spring Boot 整合 Quartz 集群執行預設及動態排程 Quartz Misfire Handling Instruction Quartz 是 Java 生態中一套成熟的開源排程框架，其完整的排程功能包含多樣排程設定、自動任務調度、任務持久化，以及支援分散式排程調度、自動負載平衡，讓排程可以輕鬆運行、應用可以輕鬆 scale out
概念 核心元件 Job: 任務需要執行的內容；Job 有區分是否可併行執行，不能併行執行意思是只有上一次觸發的任務執行完後才能觸發下一次執行；另外，一個 Job 可以關聯到多個 Trigger，也就是同一個 Job 可以以不同時間規則多次觸發，但一個 Trigger 只能關聯一個 Job JobDetail: 包含任務的設定，也就是要實例化 Job 時的相關設定；由 JobKey (Job 名稱 name 和分組 group)、JobClass、JobDataMap (任務相關數據)、JobBuilder 組成，並可以設定任務調度的方案和策略，並指定要調度的 Job 類別 Trigger: 設定觸發執行 Job 實例的時間規則；Scheduler 負責掃描需要執行的 Job 任務，而 Trigger 負責告訴 Scheduler 何時執行；Quartz 2.3.2 版提供 SimpleTrigger、CronTrigger、DailyTimeIntervalTrigger 及 CalendarIntervalTrigger 等 Trigger Scheduler: 任務調度器，會讀取 Trigger 從而觸發以 JobDetail 產生的 Job 實例；一個調度器中可以註冊多個 JobDetail 及 Trigger，只要 JobDetail 與 Trigger 組合，就可以被 Scheduler 調度 單體 stand-alone 模式運作 流程很簡單，就是 Scheduler 負責管理 Trigger 及 Job，會讀取 Trigger 並按照設定觸發時間規則，到時間就依照 JobDetail 設定產生跟該 Trigger 關聯的 Job 實例並運行</description>
    </item>
    
  </channel>
</rss>
