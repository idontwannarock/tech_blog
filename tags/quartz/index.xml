<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Quartz on Howard Tech Note</title>
    <link>https://blog.idontwannarock.dev/tags/quartz/</link>
    <description>Recent content in Quartz on Howard Tech Note</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <copyright>This website by Howard Wang is licensed under a Creative Common Attribution-ShareAlike 4.0 International License.</copyright>
    <lastBuildDate>Tue, 29 Nov 2022 15:21:19 +0800</lastBuildDate>
    <atom:link href="https://blog.idontwannarock.dev/tags/quartz/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Quartz Misfire Handling Instruction</title>
      <link>https://blog.idontwannarock.dev/2022/11/quartz-misfire-handling-instruction/</link>
      <pubDate>Tue, 29 Nov 2022 15:21:19 +0800</pubDate>
      <guid>https://blog.idontwannarock.dev/2022/11/quartz-misfire-handling-instruction/</guid>
      <description>&lt;p&gt;Quartz 系列：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://blog.idontwannarock.dev/2022/11/quartz-intro/&#34;&gt;Quartz 介紹&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://blog.idontwannarock.dev/2022/11/quartz-cluster-fixed-and-dynamic-trigger-spring-boot-integration/&#34;&gt;Spring Boot 整合 Quartz 集群執行預設及動態排程&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;Quartz Misfire Handling Instruction&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;使用 Quartz 來幫助排程管理很方便，但還有一個需要注意的地方，就是設定 misfire handling instruction&lt;/p&gt;&#xA;&lt;h1 id=&#34;misfire-概念&#34;&gt;Misfire 概念&lt;/h1&gt;&#xA;&lt;p&gt;首先要來釐清在 Quartz 的架構下，什麼情況能稱為 misfire，其實講到底就只有一種：「Job 在到達預定該觸發的時間未觸發」&lt;/p&gt;&#xA;&lt;p&gt;但怎樣算是未觸發，其實主要有兩個條件，第一個是設定的「觸發時間」，第二個則是「&lt;code&gt;misfireThreshold&lt;/code&gt;」&lt;/p&gt;&#xA;&lt;p&gt;舉例來說如果有一個 Job 設定 12:00 觸發，並且 Quartz 的 &lt;code&gt;misfireThreshold&lt;/code&gt; 設定為 2min，因此當我在 12:01 準備要執行的時候，因為已經超過設定的觸發時間，但還沒有超過 &lt;code&gt;misfireThreshold&lt;/code&gt; 的 2min，所以並不會被 Quartz 認為是 misfire&lt;/p&gt;&#xA;&lt;p&gt;那另一方面來說，以同樣的例子而言，如果 Quartz 準備要執行的時候已經是 12:03，那這個 Job 的這次執行就會被認為是 misfire，這時候 Quartz 就會依照設定好的 misfire handling instruction 來執行未觸發時的動作&lt;/p&gt;&#xA;&lt;p&gt;這樣舉例就能很清楚的理解 &lt;code&gt;misfireThreshold&lt;/code&gt; 的意義&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;要在 Spring Boot 整合 Quartz 專案中設定 &lt;code&gt;misfireThreshold&lt;/code&gt;，可在 properties 檔中設定 &lt;code&gt;spring.quartz.properties.org.quartz.jobStore.misfireThreshold=60000&lt;/code&gt;，這個參數的 default 就是 60000 milliseconds 也就是一分鐘&lt;/p&gt;</description>
    </item>
    <item>
      <title>Spring Boot 整合 Quartz 集群執行預設及動態排程</title>
      <link>https://blog.idontwannarock.dev/2022/11/quartz-cluster-fixed-and-dynamic-trigger-spring-boot-integration/</link>
      <pubDate>Tue, 15 Nov 2022 16:54:13 +0800</pubDate>
      <guid>https://blog.idontwannarock.dev/2022/11/quartz-cluster-fixed-and-dynamic-trigger-spring-boot-integration/</guid>
      <description>&lt;p&gt;Quartz 系列：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://blog.idontwannarock.dev/2022/11/quartz-intro/&#34;&gt;Quartz 介紹&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;Spring Boot 整合 Quartz 集群執行預設及動態排程&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://blog.idontwannarock.dev/2022/11/quartz-misfire-handling-instruction/&#34;&gt;Quartz Misfire Handling Instruction&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Spring Boot 官方本身就有 &lt;code&gt;spring-boot-starter-quartz&lt;/code&gt; 來提供 Quartz 整合，所以在 Spring Boot 當中使用基本 Quartz 功能已經非常簡單&lt;/p&gt;&#xA;&lt;p&gt;至於動態產生排程，網路上也很多教學，只是大多是採用 API 呼叫的方式去動態產生、運行、暫停、刪除排程等功能，而幾乎沒看到利用預設排程定時從 database 取得動態排程設定，並動態產生或移除排程的功能&lt;/p&gt;&#xA;&lt;p&gt;接下來探討如何在 Spring Boot 整合 Quartz 的框架中實作以上需求，來達成依照自訂動態排程來發通知的需求&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;以下討論採用 Spring Boot 2.7.5 及 Quartz 2.3.2 版本並搭配 MySQL 做持久化&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h1 id=&#34;database-schema&#34;&gt;Database Schema&lt;/h1&gt;&#xA;&lt;p&gt;首先需要在 MySQL 內建立相關的 schema，可以利用官方提供的這個 &lt;a href=&#34;https://github.com/quartz-scheduler/quartz/blob/master/quartz-core/src/main/resources/org/quartz/impl/jdbcjobstore/tables_mysql_innodb.sql&#34;&gt;script&lt;/a&gt; 來建立，並額外依照以下 sql 建立動態通知排程的 table：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;create&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;table&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;not&lt;/span&gt; exist NOTIFICATION_SCHEDULE&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ID                &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;int&lt;/span&gt; auto_increment&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#ff79c6&#34;&gt;primary&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;key&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    CRON              &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;varchar&lt;/span&gt;(&lt;span style=&#34;color:#bd93f9&#34;&gt;100&lt;/span&gt;)                          &lt;span style=&#34;color:#ff79c6&#34;&gt;not&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;null&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;comment&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;Quartz type cron&amp;#39;&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    TIMEZONE          &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;varchar&lt;/span&gt;(&lt;span style=&#34;color:#bd93f9&#34;&gt;64&lt;/span&gt;) &lt;span style=&#34;color:#ff79c6&#34;&gt;default&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;Asia/Taipei&amp;#39;&lt;/span&gt;     &lt;span style=&#34;color:#ff79c6&#34;&gt;null&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    TEMPLATE_ID       &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;int&lt;/span&gt;                                   &lt;span style=&#34;color:#ff79c6&#34;&gt;not&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;null&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    IS_ONLINE         tinyint(&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;)  &lt;span style=&#34;color:#ff79c6&#34;&gt;default&lt;/span&gt; &lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;                 &lt;span style=&#34;color:#ff79c6&#34;&gt;null&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    IS_DELETED        tinyint(&lt;span style=&#34;color:#bd93f9&#34;&gt;1&lt;/span&gt;)  &lt;span style=&#34;color:#ff79c6&#34;&gt;default&lt;/span&gt; &lt;span style=&#34;color:#bd93f9&#34;&gt;0&lt;/span&gt;                 &lt;span style=&#34;color:#ff79c6&#34;&gt;null&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    CREATE_TIME       datetime    &lt;span style=&#34;color:#ff79c6&#34;&gt;default&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;null&lt;/span&gt;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    UPDATE_TIME       datetime                              &lt;span style=&#34;color:#ff79c6&#34;&gt;null&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;on&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;update&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;CURRENT_TIMESTAMP&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;) &lt;span style=&#34;color:#ff79c6&#34;&gt;comment&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#39;紀錄通知排程資訊&amp;#39;&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;dependency&#34;&gt;Dependency&lt;/h1&gt;&#xA;&lt;p&gt;接著在 pom 檔引用以下依賴：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Quartz 介紹</title>
      <link>https://blog.idontwannarock.dev/2022/11/quartz-intro/</link>
      <pubDate>Tue, 15 Nov 2022 16:24:46 +0800</pubDate>
      <guid>https://blog.idontwannarock.dev/2022/11/quartz-intro/</guid>
      <description>&lt;p&gt;Quartz 系列：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Quartz 介紹&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://blog.idontwannarock.dev/2022/11/quartz-cluster-fixed-and-dynamic-trigger-spring-boot-integration/&#34;&gt;Spring Boot 整合 Quartz 集群執行預設及動態排程&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://blog.idontwannarock.dev/2022/11/quartz-misfire-handling-instruction/&#34;&gt;Quartz Misfire Handling Instruction&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Quartz 是 Java 生態中一套成熟的開源排程框架，其完整的排程功能包含多樣排程設定、自動任務調度、任務持久化，以及支援分散式排程調度、自動負載平衡，讓排程可以輕鬆運行、應用可以輕鬆 scale out&lt;/p&gt;&#xA;&lt;h1 id=&#34;概念&#34;&gt;概念&lt;/h1&gt;&#xA;&lt;h2 id=&#34;核心元件&#34;&gt;核心元件&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;Job&lt;/code&gt;: 任務需要執行的內容；&lt;code&gt;Job&lt;/code&gt; 有區分是否可併行執行，不能併行執行意思是只有上一次觸發的任務執行完後才能觸發下一次執行；另外，一個 &lt;code&gt;Job&lt;/code&gt; 可以關聯到多個 &lt;code&gt;Trigger&lt;/code&gt;，也就是同一個 &lt;code&gt;Job&lt;/code&gt; 可以以不同時間規則多次觸發，但一個 &lt;code&gt;Trigger&lt;/code&gt; 只能關聯一個 &lt;code&gt;Job&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;JobDetail&lt;/code&gt;: 包含任務的設定，也就是要實例化 &lt;code&gt;Job&lt;/code&gt; 時的相關設定；由 &lt;code&gt;JobKey&lt;/code&gt; (Job 名稱 name 和分組 group)、&lt;code&gt;JobClass&lt;/code&gt;、&lt;code&gt;JobDataMap&lt;/code&gt; (任務相關數據)、&lt;code&gt;JobBuilder&lt;/code&gt; 組成，並可以設定任務調度的方案和策略，並指定要調度的 &lt;code&gt;Job&lt;/code&gt; 類別&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Trigger&lt;/code&gt;: 設定觸發執行 &lt;code&gt;Job&lt;/code&gt; 實例的時間規則；&lt;code&gt;Scheduler&lt;/code&gt; 負責掃描需要執行的 &lt;code&gt;Job&lt;/code&gt; 任務，而 &lt;code&gt;Trigger&lt;/code&gt; 負責告訴 &lt;code&gt;Scheduler&lt;/code&gt; 何時執行；Quartz 2.3.2 版提供 &lt;code&gt;SimpleTrigger&lt;/code&gt;、&lt;code&gt;CronTrigger&lt;/code&gt;、&lt;code&gt;DailyTimeIntervalTrigger&lt;/code&gt; 及 &lt;code&gt;CalendarIntervalTrigger&lt;/code&gt; 等 &lt;code&gt;Trigger&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Scheduler&lt;/code&gt;: 任務調度器，會讀取 &lt;code&gt;Trigger&lt;/code&gt; 從而觸發以 &lt;code&gt;JobDetail&lt;/code&gt; 產生的 &lt;code&gt;Job&lt;/code&gt; 實例；一個調度器中可以註冊多個 &lt;code&gt;JobDetail&lt;/code&gt; 及 &lt;code&gt;Trigger&lt;/code&gt;，只要 &lt;code&gt;JobDetail&lt;/code&gt; 與 &lt;code&gt;Trigger&lt;/code&gt; 組合，就可以被 &lt;code&gt;Scheduler&lt;/code&gt; 調度&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;單體-stand-alone-模式運作&#34;&gt;單體 stand-alone 模式運作&lt;/h2&gt;&#xA;&lt;p&gt;流程很簡單，就是 &lt;code&gt;Scheduler&lt;/code&gt; 負責管理 &lt;code&gt;Trigger&lt;/code&gt; 及 &lt;code&gt;Job&lt;/code&gt;，會讀取 &lt;code&gt;Trigger&lt;/code&gt; 並按照設定觸發時間規則，到時間就依照 &lt;code&gt;JobDetail&lt;/code&gt; 設定產生跟該 &lt;code&gt;Trigger&lt;/code&gt; 關聯的 &lt;code&gt;Job&lt;/code&gt; 實例並運行&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
