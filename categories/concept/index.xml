<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Concept on Howard Tech Note</title>
    <link>https://blog.idontwannarock.dev/categories/concept/</link>
    <description>Recent content in Concept on Howard Tech Note</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <copyright>This website by Howard Wang is licensed under a Creative Common Attribution-ShareAlike 4.0 International License.</copyright>
    <lastBuildDate>Tue, 29 Nov 2022 15:21:19 +0800</lastBuildDate>
    <atom:link href="https://blog.idontwannarock.dev/categories/concept/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Quartz Misfire Handling Instruction</title>
      <link>https://blog.idontwannarock.dev/2022/11/quartz-misfire-handling-instruction/</link>
      <pubDate>Tue, 29 Nov 2022 15:21:19 +0800</pubDate>
      <guid>https://blog.idontwannarock.dev/2022/11/quartz-misfire-handling-instruction/</guid>
      <description>&lt;p&gt;Quartz 系列：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://blog.idontwannarock.dev/2022/11/quartz-intro/&#34;&gt;Quartz 介紹&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://blog.idontwannarock.dev/2022/11/quartz-cluster-fixed-and-dynamic-trigger-spring-boot-integration/&#34;&gt;Spring Boot 整合 Quartz 集群執行預設及動態排程&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;Quartz Misfire Handling Instruction&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;使用 Quartz 來幫助排程管理很方便，但還有一個需要注意的地方，就是設定 misfire handling instruction&lt;/p&gt;&#xA;&lt;h1 id=&#34;misfire-概念&#34;&gt;Misfire 概念&lt;/h1&gt;&#xA;&lt;p&gt;首先要來釐清在 Quartz 的架構下，什麼情況能稱為 misfire，其實講到底就只有一種：「Job 在到達預定該觸發的時間未觸發」&lt;/p&gt;&#xA;&lt;p&gt;但怎樣算是未觸發，其實主要有兩個條件，第一個是設定的「觸發時間」，第二個則是「&lt;code&gt;misfireThreshold&lt;/code&gt;」&lt;/p&gt;&#xA;&lt;p&gt;舉例來說如果有一個 Job 設定 12:00 觸發，並且 Quartz 的 &lt;code&gt;misfireThreshold&lt;/code&gt; 設定為 2min，因此當我在 12:01 準備要執行的時候，因為已經超過設定的觸發時間，但還沒有超過 &lt;code&gt;misfireThreshold&lt;/code&gt; 的 2min，所以並不會被 Quartz 認為是 misfire&lt;/p&gt;&#xA;&lt;p&gt;那另一方面來說，以同樣的例子而言，如果 Quartz 準備要執行的時候已經是 12:03，那這個 Job 的這次執行就會被認為是 misfire，這時候 Quartz 就會依照設定好的 misfire handling instruction 來執行未觸發時的動作&lt;/p&gt;&#xA;&lt;p&gt;這樣舉例就能很清楚的理解 &lt;code&gt;misfireThreshold&lt;/code&gt; 的意義&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;要在 Spring Boot 整合 Quartz 專案中設定 &lt;code&gt;misfireThreshold&lt;/code&gt;，可在 properties 檔中設定 &lt;code&gt;spring.quartz.properties.org.quartz.jobStore.misfireThreshold=60000&lt;/code&gt;，這個參數的 default 就是 60000 milliseconds 也就是一分鐘&lt;/p&gt;</description>
    </item>
    <item>
      <title>Quartz 介紹</title>
      <link>https://blog.idontwannarock.dev/2022/11/quartz-intro/</link>
      <pubDate>Tue, 15 Nov 2022 16:24:46 +0800</pubDate>
      <guid>https://blog.idontwannarock.dev/2022/11/quartz-intro/</guid>
      <description>&lt;p&gt;Quartz 系列：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Quartz 介紹&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://blog.idontwannarock.dev/2022/11/quartz-cluster-fixed-and-dynamic-trigger-spring-boot-integration/&#34;&gt;Spring Boot 整合 Quartz 集群執行預設及動態排程&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://blog.idontwannarock.dev/2022/11/quartz-misfire-handling-instruction/&#34;&gt;Quartz Misfire Handling Instruction&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Quartz 是 Java 生態中一套成熟的開源排程框架，其完整的排程功能包含多樣排程設定、自動任務調度、任務持久化，以及支援分散式排程調度、自動負載平衡，讓排程可以輕鬆運行、應用可以輕鬆 scale out&lt;/p&gt;&#xA;&lt;h1 id=&#34;概念&#34;&gt;概念&lt;/h1&gt;&#xA;&lt;h2 id=&#34;核心元件&#34;&gt;核心元件&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;Job&lt;/code&gt;: 任務需要執行的內容；&lt;code&gt;Job&lt;/code&gt; 有區分是否可併行執行，不能併行執行意思是只有上一次觸發的任務執行完後才能觸發下一次執行；另外，一個 &lt;code&gt;Job&lt;/code&gt; 可以關聯到多個 &lt;code&gt;Trigger&lt;/code&gt;，也就是同一個 &lt;code&gt;Job&lt;/code&gt; 可以以不同時間規則多次觸發，但一個 &lt;code&gt;Trigger&lt;/code&gt; 只能關聯一個 &lt;code&gt;Job&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;JobDetail&lt;/code&gt;: 包含任務的設定，也就是要實例化 &lt;code&gt;Job&lt;/code&gt; 時的相關設定；由 &lt;code&gt;JobKey&lt;/code&gt; (Job 名稱 name 和分組 group)、&lt;code&gt;JobClass&lt;/code&gt;、&lt;code&gt;JobDataMap&lt;/code&gt; (任務相關數據)、&lt;code&gt;JobBuilder&lt;/code&gt; 組成，並可以設定任務調度的方案和策略，並指定要調度的 &lt;code&gt;Job&lt;/code&gt; 類別&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Trigger&lt;/code&gt;: 設定觸發執行 &lt;code&gt;Job&lt;/code&gt; 實例的時間規則；&lt;code&gt;Scheduler&lt;/code&gt; 負責掃描需要執行的 &lt;code&gt;Job&lt;/code&gt; 任務，而 &lt;code&gt;Trigger&lt;/code&gt; 負責告訴 &lt;code&gt;Scheduler&lt;/code&gt; 何時執行；Quartz 2.3.2 版提供 &lt;code&gt;SimpleTrigger&lt;/code&gt;、&lt;code&gt;CronTrigger&lt;/code&gt;、&lt;code&gt;DailyTimeIntervalTrigger&lt;/code&gt; 及 &lt;code&gt;CalendarIntervalTrigger&lt;/code&gt; 等 &lt;code&gt;Trigger&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Scheduler&lt;/code&gt;: 任務調度器，會讀取 &lt;code&gt;Trigger&lt;/code&gt; 從而觸發以 &lt;code&gt;JobDetail&lt;/code&gt; 產生的 &lt;code&gt;Job&lt;/code&gt; 實例；一個調度器中可以註冊多個 &lt;code&gt;JobDetail&lt;/code&gt; 及 &lt;code&gt;Trigger&lt;/code&gt;，只要 &lt;code&gt;JobDetail&lt;/code&gt; 與 &lt;code&gt;Trigger&lt;/code&gt; 組合，就可以被 &lt;code&gt;Scheduler&lt;/code&gt; 調度&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;單體-stand-alone-模式運作&#34;&gt;單體 stand-alone 模式運作&lt;/h2&gt;&#xA;&lt;p&gt;流程很簡單，就是 &lt;code&gt;Scheduler&lt;/code&gt; 負責管理 &lt;code&gt;Trigger&lt;/code&gt; 及 &lt;code&gt;Job&lt;/code&gt;，會讀取 &lt;code&gt;Trigger&lt;/code&gt; 並按照設定觸發時間規則，到時間就依照 &lt;code&gt;JobDetail&lt;/code&gt; 設定產生跟該 &lt;code&gt;Trigger&lt;/code&gt; 關聯的 &lt;code&gt;Job&lt;/code&gt; 實例並運行&lt;/p&gt;</description>
    </item>
    <item>
      <title>XSS 防範簡介</title>
      <link>https://blog.idontwannarock.dev/2022/11/xss_prevention_intro/</link>
      <pubDate>Tue, 01 Nov 2022 14:00:26 +0800</pubDate>
      <guid>https://blog.idontwannarock.dev/2022/11/xss_prevention_intro/</guid>
      <description>&lt;p&gt;XSS 系列：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;XSS 防範簡介&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://blog.idontwannarock.dev/2022/11/xss_prevention_spring_boot/&#34;&gt;Spring Boot 後端實作 XSS 防範&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;跨網站指令碼 Cross-site Scripting, XSS，是一種代碼注入的攻擊，讓攻擊者在網頁上注入代碼，而其他使用者在觀看網頁的時候就會受到影響。&lt;/p&gt;&#xA;&lt;h2 id=&#34;攻擊模式&#34;&gt;攻擊模式&lt;/h2&gt;&#xA;&lt;p&gt;以電商系統舉例，例如管理後台網頁表單的商品描述輸入欄位 Input 在沒有進行相對應防範的前提下，攻擊者可以藉由輸入 &lt;code&gt;&amp;lt;script&amp;gt;alert(document.cookie)&amp;lt;/script&amp;gt;&lt;/code&gt; 這段內容，並透過 API 保存到資料庫，如此一來下次其他使用者在瀏覽該商品的時候，也同樣從後端取得資料庫中的這段描述內容，並且顯示在網頁上，則使用者在載入網頁的時候，瀏覽器就可能會跳出彈窗並把使用者當下的 cookie 直接顯示出來。&lt;/p&gt;&#xA;&lt;p&gt;當然實際的攻擊不會只有跳出彈窗並印出資料這麼簡單，可能是竊取 cookie 或任何 JavaScript 可以存取的敏感資料、側錄使用者行為，或跳轉惡意網址等等行為。&lt;/p&gt;&#xA;&lt;p&gt;當然注入的代碼也不僅限於 JavaScript，也可以是 Java、VBScript 等，甚至是普通的 HTML。&lt;/p&gt;&#xA;&lt;h2 id=&#34;跟-csrf-的區別&#34;&gt;跟 CSRF 的區別&lt;/h2&gt;&#xA;&lt;p&gt;另一種常搞混的攻擊是跨站請求偽造 Cross-site Request Forgery, CSRF，是一種挾制使用者在當前已登入的 Web 應用程式上執行非本意的操作的攻擊方法。&lt;/p&gt;&#xA;&lt;p&gt;例如使用者可能使用某網路銀行做轉帳，當使用者不小心存取到惡意的網址，就可能因為瀏覽器中之前登錄該網路銀行的登錄資訊尚未過期，所以被存取的網路銀行因為信任瀏覽器保存的登錄資訊，而認為是真正的使用者在進行操作而去執行某些動作。&lt;/p&gt;&#xA;&lt;p&gt;跟 XSS 相比，XSS 利用的是「&lt;strong&gt;使用者對指定網站的信任&lt;/strong&gt;」，CSRF 利用的則是「&lt;strong&gt;網站對使用者網頁瀏覽器的信任&lt;/strong&gt;」。&lt;/p&gt;&#xA;&lt;h2 id=&#34;防範措施&#34;&gt;防範措施&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html&#34;&gt;OWASP 網站&lt;/a&gt; 有提出一些基本的防範措施，但要能真正達到成效，是需要多種手段結合、前後端合作才能達到。並且攻擊手段常常是並用，所以採取防範措施的時候，也要考慮並防範其他種攻擊手段。&lt;/p&gt;&#xA;&lt;h3 id=&#34;output-encoding&#34;&gt;Output Encoding&lt;/h3&gt;&#xA;&lt;p&gt;這部分首先會需要了解使用的 Web Framework 的安全措施跟限制在哪。&lt;/p&gt;&#xA;&lt;p&gt;例如 React 預設會對 render 內容進行跳脫處理 (escape)，將所有的資料都視為文字字串，等同使用原生的 &lt;code&gt;textContent&lt;/code&gt;；但有些時候我們就是需要 React 將內容也 render 成 HTML，因此需要使用 &lt;code&gt;dangerouslySetInnerHTML&lt;/code&gt; 來做 render，那可能就沒辦法依靠框架預設的方式去阻止 XSS，而是要使用其他手段來做處理。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java Optional 為何不推薦做為類別屬性</title>
      <link>https://blog.idontwannarock.dev/2022/10/java_optional_not_recommand_as_field/</link>
      <pubDate>Sat, 01 Oct 2022 21:44:34 +0800</pubDate>
      <guid>https://blog.idontwannarock.dev/2022/10/java_optional_not_recommand_as_field/</guid>
      <description>&lt;p&gt;大家有在寫 Java 1.8+ 的時候使用新出的 &lt;code&gt;Optional&lt;/code&gt; 類別來處理 &lt;code&gt;null&lt;/code&gt; 的問題嗎？&lt;/p&gt;&#xA;&lt;p&gt;那在使用的時候有沒有碰到 IntelliJ 提示 &lt;code&gt;Optional&lt;/code&gt; 不推薦用來當作類別的 field 的黃色警告 (warning) 呢？訊息應該大致如下&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;/**&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; * A container object which may or may not contain a non-{@code null} value.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; * If a value is present, {@code isPresent()} returns {@code true}. If no&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; * value is present, the object is considered &amp;lt;i&amp;gt;empty&amp;lt;/i&amp;gt; and&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; * {@code isPresent()} returns {@code false}.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; *&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; * &amp;lt;p&amp;gt;Additional methods that depend on the presence or absence of a contained&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; * value are provided, such as {@link #orElse(Object) orElse()}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; * (returns a default value if no value is present) and&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; * {@link #ifPresent(Consumer) ifPresent()} (performs an&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; * action if a value is present).&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; *&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; * &amp;lt;p&amp;gt;This is a &amp;lt;a href=&amp;#34;../lang/doc-files/ValueBased.html&amp;#34;&amp;gt;value-based&amp;lt;/a&amp;gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; * class; use of identity-sensitive operations (including reference equality&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; * ({@code ==}), identity hash code, or synchronization) on instances of&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; * {@code Optional} may have unpredictable results and should be avoided.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; *&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; * @apiNote&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; * {@code Optional} is primarily intended for use as a method return type where&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; * there is a clear need to represent &amp;#34;no result,&amp;#34; and where using {@code null}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; * is likely to cause errors. A variable whose type is {@code Optional} should&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; * never itself be {@code null}; it should always point to an {@code Optional}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; * instance.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; *&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; * @param &amp;lt;T&amp;gt; the type of value&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; * @since 1.8&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt; */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我剛碰到的時候感覺很奇怪，用 &lt;code&gt;Optional&lt;/code&gt; 來當 field 表示我們想表達這個 field 有可能是 &lt;code&gt;null&lt;/code&gt; 有什麼不對嗎？為什麼 IntelliJ 要警告我呢？&lt;/p&gt;</description>
    </item>
    <item>
      <title>gRPC 概念</title>
      <link>https://blog.idontwannarock.dev/2021/12/grpc/</link>
      <pubDate>Mon, 27 Dec 2021 09:44:31 +0800</pubDate>
      <guid>https://blog.idontwannarock.dev/2021/12/grpc/</guid>
      <description>&lt;p&gt;在前幾篇大略了解 HTTP/2 的概念後，就可以來了解 gRPC 的運作概念了&lt;/p&gt;&#xA;&lt;p&gt;HTTP/2 系列:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://blog.idontwannarock.dev/2021/12/http2/&#34;&gt;HTTP/2 系列 - HTTP/2 概念&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://blog.idontwannarock.dev/2021/12/http_server_push/&#34;&gt;HTTP/2 系列 - HTTP Server Push 技術&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;概念&#34;&gt;概念&lt;/h2&gt;&#xA;&lt;p&gt;gRPC 原本是 Google 內部的 RPC 系統，後來開源後，近年成為很熱門的 RPC 系統，採用 HTTP/2 做傳輸，ProtoBuf 作為介面描述語言 (interface description language)，提供身分驗證 (authentication)、雙向串流 (bidirectional streaming)、流量控制 (flow control)、阻塞或非阻塞綁定 (blocking or nonblocking binding)、取消 (cancellation) 及逾時 (timeouts) 等特性&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;RPC Remote Procedure Call 遠端程序呼叫指服務之間互相溝通就如同呼叫本地程式一般，不須關注呼叫互動的細節。例如以前的 CORBA, Java RMI 等&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;使用-grpc-api&#34;&gt;使用 gRPC API&lt;/h3&gt;&#xA;&lt;p&gt;主要是透過 .proto 檔定義 service 結構，再透過 ProtoBuf compiler 的幫助產生各語言的 client/server 端代碼&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;client 端會有一個本地物件 stub 實作 service 中相同的方法，讓 client 端可以直接呼叫該本地物件的方法，gRPC 會處理發出 request 以及從 server 端的 ProtoBuf response&lt;/li&gt;&#xA;&lt;li&gt;server 端會真正實作 service 中宣告的方法，並運行 gRPC server 來處理 client 端的呼叫，gRPC infra 會將 request 解碼，執行 service 方法，再將 service response 編碼&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://res.cloudinary.com/dcvgho2zc/image/upload/c_scale,h_304/v1640339739/Tech%20Blog/grpc-call.png&#34; alt=&#34;gRPC 呼叫關係&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>HTTP/2 系列 - HTTP Server Push 技術</title>
      <link>https://blog.idontwannarock.dev/2021/12/http_server_push/</link>
      <pubDate>Fri, 24 Dec 2021 15:49:27 +0800</pubDate>
      <guid>https://blog.idontwannarock.dev/2021/12/http_server_push/</guid>
      <description>&lt;p&gt;這篇預計是 HTTP/2 系列的最後一篇，之前在系列前面已經釐清了 HTTP/2 的概念了，其中我比較有興趣的就是 HTTP/2 的 server push 新特性，這邊就繼續來了解一下吧~&lt;/p&gt;&#xA;&lt;p&gt;HTTP/2 系列:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://blog.idontwannarock.dev/2021/12/http2/&#34;&gt;HTTP/2 系列 - HTTP/2 概念&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;HTTP/2 系列 - HTTP Server Push 技術&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;http-server-push-技術&#34;&gt;HTTP Server Push 技術&lt;/h2&gt;&#xA;&lt;p&gt;首先來探討一下有哪些基於 HTTP 協定的 server push 技術&lt;/p&gt;&#xA;&lt;p&gt;相對於 request-response 模型必須要一端發出 request 後另一端再對應的發出 response，server push 一般是指不經 client 端發出指定的 request 就由 server 端發出 message 給 client 端&lt;/p&gt;&#xA;&lt;p&gt;這種技術在某些情況是很有用的，像是需要「即時」更新資料的應用場景，例如比賽分數，當然這可以在 client 端採用定時輪詢 (polling) 的方式來實作，但這樣其實對於 client 端或 server 端都會造成資源的浪費，因為可能大多數請求實際上都沒有需要更新的資料，實際上知道資料有變動的就是 server 端，如果可以由 server 端在資料真正有變動的時候主動通知 client 端，就可以將資料元的浪費降到最低&lt;/p&gt;&#xA;&lt;p&gt;也因為在許多需要「即時」的情況下由 server 端主動通知 client 端都可以節省大量效能浪費，所以才會一直都有追求 server push 技術的需求存在&lt;/p&gt;</description>
    </item>
    <item>
      <title>HTTP/2 系列 - HTTP/2 概念</title>
      <link>https://blog.idontwannarock.dev/2021/12/http2/</link>
      <pubDate>Tue, 21 Dec 2021 09:06:29 +0800</pubDate>
      <guid>https://blog.idontwannarock.dev/2021/12/http2/</guid>
      <description>&lt;p&gt;從 2015 年 RFC 7540 正式發表後，至今 HTTP/2 已經被絕大多數主流瀏覽器所支援，並且是正當紅的 gRPC 的基礎，在研究 gPRC 之前，先來釐清一下 HTTP/2 的概念&lt;/p&gt;&#xA;&lt;p&gt;這篇是 HTTP/2 系列文章的第一篇:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;HTTP/2 系列 - HTTP/2 概念&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://blog.idontwannarock.dev/2021/12/http_server_push/&#34;&gt;HTTP/2 系列 - HTTP Server Push 技術&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;不過，我其實只想研究我想研究的部分，所以不見得會把 HTTP/2 所有相關的內容都研究一遍&lt;/p&gt;&#xA;&lt;h2 id=&#34;從遠古-http10-開始&#34;&gt;從遠古 HTTP/1.0 開始&lt;/h2&gt;&#xA;&lt;p&gt;HTTP 是定義在 OSI 模型第七層 Application Layer 網路協議，HTTP/1.0 採取先進先出 (first-in first-out, FIFO) 策略，每次請求/回應都是有序的，必須等到請求收到對應回應後，才能進行下一次請求&lt;/p&gt;&#xA;&lt;p&gt;HTTP 在 Transport Layer 採用 TCP 連線來通訊，而 TCP 要在 client/server 之間建立連線，是靠著三向交握 (three-way handshake) 來完成；而傳輸完成要斷線時則要做四次握手 (four-way handshake)。如果還有 TLS，那握手的來回通訊次數 (round-trip time, RTT) 就更多次了&lt;/p&gt;&#xA;&lt;p&gt;而在最初的 HTTP/1.0 的年代，硬體普遍效能都不高，為了提高系統的效率，所以 HTTP/1.0 規定 client/server 只能保持短暫的連線，所以 client 每次請求最少都要經過三向交握建立 TCP 連線，而 server 完成該請求的處理後也必須立刻進行四次握手斷開連線&lt;/p&gt;</description>
    </item>
    <item>
      <title>Spring Security 整合 RBAC</title>
      <link>https://blog.idontwannarock.dev/2019/05/spring_security_rbac/</link>
      <pubDate>Thu, 30 May 2019 15:33:07 +0800</pubDate>
      <guid>https://blog.idontwannarock.dev/2019/05/spring_security_rbac/</guid>
      <description>&lt;p&gt;目前比較主流的 &lt;a href=&#34;https://en.wikipedia.org/wiki/Role-based_access_control&#34;&gt;Role-based Access Control, RBAC&lt;/a&gt; 算是比較成熟且彈性的權限架構，若要在 Spring Security 實作 RBAC 並搭配 JWT 或 OAuth 2.0，大概要探討兩個問題&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;是否值得為了減少查詢資料源的次數，而將角色或權限直接置入 JWT 或 Authorization Server 回傳的 token&lt;/li&gt;&#xA;&lt;li&gt;是否採取 Spring Security 原生只使用最細粒度的權限來進行存取控制&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;關於第一個問題，目前的思考點大概就是考量系統的併發度跟使用者總數&lt;/p&gt;&#xA;&lt;p&gt;如果需要高併發，那自然希望盡量減少查詢資料的次數或資料量，盡量避免同時大量消耗 DB 資源；相反的，如果不需要高併發，那每次驗證都重新取得角色及權限資料也沒關係&lt;/p&gt;&#xA;&lt;p&gt;使用者數量的考量也是類似，如果每次查詢的成本太高，則盡量減少查詢的次數&lt;/p&gt;&#xA;&lt;p&gt;而第二個問題，則是要考量實際的業務場景&lt;/p&gt;&#xA;&lt;p&gt;如果角色跟權限很大量且複雜，或可能要考慮角色分層甚至使用者群組，或不同 Domain 有不同的權限邏輯，則可能用 Spring Security 原生方式會不敷使用，相對如果角色權限結構簡單，則直接使用原生方式可能成本較低&lt;/p&gt;&#xA;&lt;p&gt;所以以下探討主要專注於使用 Spring Security 提供的自訂空間來實作較為複雜的存取控制&lt;/p&gt;&#xA;&lt;h1 id=&#34;spring-security-權限架構&#34;&gt;Spring Security 權限架構&lt;/h1&gt;&#xA;&lt;p&gt;首先要探討 Spring Security 原生提供的權限架構&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;GrantedAuthority: 可以將每個 GrantedAuthority 想成是個別的 privilege，所以在 Spring Security 中，authority 就是 privilege 的概念&lt;/li&gt;&#xA;&lt;li&gt;Role: 在 Spring Security 中為了保持彈性，Role 可以當作 Authority 也可以當作一組 Authority 的組合&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Role as Authority: 直接把 Role 當成一種 Authority 的情況，就是將 Role 當作一個有 ROLE_ 前綴的字串，這種情況下 Role 跟 Authority 就只是語意上的差別&lt;/li&gt;&#xA;&lt;li&gt;Role as Container: Role 可以包含一組 Authority，Spring Security 在這個概念上沒有提供太多指引說明，需要自行實作&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.baeldung.com/spring-security-granted-authority-vs-role&#34;&gt;Granted Authority Versus Role in Spring Security&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Github Flow 簡介</title>
      <link>https://blog.idontwannarock.dev/2019/05/github_flow_intro/</link>
      <pubDate>Wed, 29 May 2019 10:52:45 +0800</pubDate>
      <guid>https://blog.idontwannarock.dev/2019/05/github_flow_intro/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://guides.github.com/introduction/flow/&#34;&gt;Understanding the GitHub flow&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;GitHub flow 只有一條原則：&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;在 master 的任何 commit 永遠都是可以被部署的&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;所以所有要做開發的 branch 都直接從 master 分支出去，不論是 feature 或 fix&lt;/p&gt;&#xA;&lt;p&gt;開發的每個 commit 都要寫清楚 message，註明該 commit 做的變動以及理由等等&lt;/p&gt;&#xA;&lt;p&gt;當開發到一定階段後，就可以對 master 開 Pull Request, PR，這在 GitHub flow 很重要&lt;/p&gt;&#xA;&lt;p&gt;如果是用 Fork &amp;amp; Pull 模式，PR 就是用來通知專案維護者關於你希望他們考慮的變更；如果是用 Shared Repository 模式，則 PR 就像是用來開一個討論空間，在 merge 到 master 之前來做 code review 或針對特定變更的討論&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Fork &amp;amp; Pull 模式就是需要先 fork 後再 pull 到本機做開發，完成並 push 後，開 PR 要求合併到主專案&lt;/p&gt;&#xA;&lt;p&gt;Shared Repository 模式則是直接可以對主專案開 branch 做開發&lt;/p&gt;</description>
    </item>
    <item>
      <title>AOP 及 Spring AOP 簡述</title>
      <link>https://blog.idontwannarock.dev/2018/04/aop_and_spring_aop_basic/</link>
      <pubDate>Tue, 10 Apr 2018 13:22:52 +0800</pubDate>
      <guid>https://blog.idontwannarock.dev/2018/04/aop_and_spring_aop_basic/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;這篇文章是初學的時候撰寫的，其中一些觀念並不正確，步驟也可能因為更新或觀念問題而不適用或者多餘，此篇文章僅為留做紀錄&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;AOP(Aspect-Oriented Programming) 是一種基於 OOP(Object-Oriented Programming) 的改進&lt;/li&gt;&#xA;&lt;li&gt;AOP 是基於動態代理 (Dynamic Proxy) 這種 design pattern&lt;/li&gt;&#xA;&lt;li&gt;AOP 主要的設計對象是切面 (Aspect)，而切面是用來模組化橫切關注點 (Cross-Cutting Concern)&lt;/li&gt;&#xA;&lt;li&gt;切面需要定義公共功能，但可以明確定義功能在哪裡或以什麼方式應用，而不必修改受影響的類別。如此切面關注點就可以被模組化到特殊的類別 (切面) 裡面&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;優點&#34;&gt;優點&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;交易相關的邏輯位於同一位置，便於維護與升級&lt;/li&gt;&#xA;&lt;li&gt;業務邏輯更簡潔，只包含核心業務代碼&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;術語及概念&#34;&gt;術語及概念&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Cross-Cutting Concern 橫切關注點&lt;/strong&gt;：橫跨應用系統多個流程、模組的功能，例如日誌 (Logging)、安全 (Security) 檢查、交易 (Transaction) 等動作，在許多流程的多個位置都需要執行，這種動作就被稱為橫切關注點&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Aspect 切面&lt;/strong&gt;：橫切關注點被模組化後的一種特殊物件；還未模組化前是橫切關注點，抽取後成為一組一組的切面；另一方面來說代理會將一個一個切面重組為橫切關注點&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Advice 通知&lt;/strong&gt;：切面必須要完成的工作或行為，也就是切面的實作內容。切面裡面的各個方法即是一個、一個的通知&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Target 目標&lt;/strong&gt;：被通知的物件，也就是要被橫切的業務邏輯類別&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Proxy 代理&lt;/strong&gt;：向目標物件通知之後創建的對象。容器會建立一個代理，依照設定去縫合 (weave) 切面到應用程式中&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;JoinPoint 連接點&lt;/strong&gt;：程序執行的某個特定位置或時機。例如某個類別的某個方法呼叫前、呼叫後、拋出異常後等等。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;連接點由兩個因素決定：&lt;strong&gt;以方法表示的程式執行點、相對執行點表示的方位&lt;/strong&gt;。例如 A 類別的 a() 方法執行前的 JoinPoint 連接點決定要素為：執行點 A#a()，方位為執行前的位置&lt;/li&gt;&#xA;&lt;li&gt;概念類比：&lt;strong&gt;JoinPoint 連接點相當於資料庫的紀錄，切面相當於查詢條件&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Pointcut 切面定義&lt;/strong&gt;：每個類別都有多個連接點，&lt;strong&gt;類別的所有方法某種程度上都可以想成是 JoinPoint 連接點&lt;/strong&gt;。AOP通過切面定位到特定的連接點&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;spring-aop&#34;&gt;Spring AOP&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;AspectJ：Java 社群最完整、最廣為人知的 AOP 實作&lt;/li&gt;&#xA;&lt;li&gt;Spring 2.0 以上，可以使用基於 AspectJ 的 annotation 註解或基於 XML 設定的 AOP&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;dependencies&#34;&gt;Dependencies&lt;/h2&gt;&#xA;&lt;h3 id=&#34;spring&#34;&gt;Spring&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;commons logging&lt;/li&gt;&#xA;&lt;li&gt;spring beans&lt;/li&gt;&#xA;&lt;li&gt;spring context&lt;/li&gt;&#xA;&lt;li&gt;spring core&lt;/li&gt;&#xA;&lt;li&gt;spring expression&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;spring-aop-1&#34;&gt;Spring AOP&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;aopalliance&lt;/li&gt;&#xA;&lt;li&gt;aspectj weaver&lt;/li&gt;&#xA;&lt;li&gt;spring aop&lt;/li&gt;&#xA;&lt;li&gt;spring aspects&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;註：Spring 框架的版本可以更動，但須一致&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java 字串判定</title>
      <link>https://blog.idontwannarock.dev/2018/02/java_string_check/</link>
      <pubDate>Tue, 06 Feb 2018 14:09:25 +0800</pubDate>
      <guid>https://blog.idontwannarock.dev/2018/02/java_string_check/</guid>
      <description>&lt;p&gt;因為開始做專題，開始要作資料檢查，首先會要碰到的就是最基本的檢查是否有輸入資料，也就是要檢查字串，記錄一下 Java 當中有關字串檢查的東西。&lt;/p&gt;&#xA;&lt;h1 id=&#34;去除字串空白&#34;&gt;去除字串空白&lt;/h1&gt;&#xA;&lt;p&gt;這主要分兩個部分，一是去掉頭尾空白，一是去掉字串中間空白。&lt;/p&gt;&#xA;&lt;p&gt;去掉頭尾空白就用 &lt;code&gt;.trim()&lt;/code&gt;，去掉字串中間空白則可以用 &lt;code&gt;.replaceAll(&amp;quot; &amp;quot;, &amp;quot;&amp;quot;)&lt;/code&gt; 的方式簡單完成。&lt;/p&gt;&#xA;&lt;p&gt;但用 &lt;code&gt;replaceAll()&lt;/code&gt; 方法有個小小的問題，就是萬一碰到的是空白字元，例如 &lt;code&gt;\t&lt;/code&gt;、&lt;code&gt;\r&lt;/code&gt; 這種就會有困難，所以必須要用正規表示式來去除，例如：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;String str &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;\t&amp;#34;&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;str.&lt;span style=&#34;color:#50fa7b&#34;&gt;replaceAll&lt;/span&gt;(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;\\s+&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;檢查空值&#34;&gt;檢查空值&lt;/h1&gt;&#xA;&lt;p&gt;接著如果要檢查字串是否有東西，要分成檢查兩種狀態，null 或空字串。&lt;/p&gt;&#xA;&lt;p&gt;這邊有幾個方法檢查這個部分，但要注意它們實際功能上的區別。&lt;/p&gt;&#xA;&lt;h2 id=&#34;length--0&#34;&gt;&lt;code&gt;.length == 0&lt;/code&gt;&lt;/h2&gt;&#xA;&lt;p&gt;這個是 Java 最原始的功能，基本上就是檢查字串長度是否為 0，回傳值型態為 boolean。&lt;/p&gt;&#xA;&lt;h2 id=&#34;isempty&#34;&gt;&lt;code&gt;.isEmpty()&lt;/code&gt;&lt;/h2&gt;&#xA;&lt;p&gt;這個方法是 Java 6.0 之後推出用來取代 &lt;code&gt;.length() == 0&lt;/code&gt; 的方法。&lt;code&gt;isEmpty()&lt;/code&gt; 其實也是在檢查字串長度是否為 0，回傳值型態一樣為 boolean。&lt;/p&gt;&#xA;&lt;h2 id=&#34;equals&#34;&gt;&lt;code&gt;.equals(&amp;quot;&amp;quot;)&lt;/code&gt;&lt;/h2&gt;&#xA;&lt;p&gt;這個功能是用字串的比對功能，比對是否為空字串，結果應該會跟前兩個方法相同。&lt;/p&gt;&#xA;&lt;h2 id=&#34;-null&#34;&gt;&lt;code&gt;!= null&lt;/code&gt;&lt;/h2&gt;&#xA;&lt;p&gt;前面幾個方法都有一個共同的問題：萬一字串為 null，全都來不及檢查就會跳 NullPointerException。&lt;/p&gt;&#xA;&lt;p&gt;所以必須要用這個方式檢查是否為 Null，再檢查是否為空字串，也就是要寫成類似下面這樣：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;String string;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; (string &lt;span style=&#34;color:#ff79c6&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;null&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; string.&lt;span style=&#34;color:#50fa7b&#34;&gt;isEmpty&lt;/span&gt;()) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#6272a4&#34;&gt;// things to do when string is neither null nor blank;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;equalsstring&#34;&gt;&lt;code&gt;&amp;quot;&amp;quot;.equals(string)&lt;/code&gt;&lt;/h2&gt;&#xA;&lt;p&gt;但有一個更簡短的方法 &lt;code&gt;&amp;quot;&amp;quot;.equals(string)&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java 樂透抽取算法初探</title>
      <link>https://blog.idontwannarock.dev/2017/11/java_lottery_algorithm_basic/</link>
      <pubDate>Wed, 15 Nov 2017 14:26:17 +0800</pubDate>
      <guid>https://blog.idontwannarock.dev/2017/11/java_lottery_algorithm_basic/</guid>
      <description>&lt;p&gt;因為做到這個經典練習演算法的題目，雖然是非常入門級的，也是讓我想了很久，覺得都做了這麼久，不記錄下來也是蠻可惜。&lt;/p&gt;&#xA;&lt;h1 id=&#34;題目&#34;&gt;題目&lt;/h1&gt;&#xA;&lt;p&gt;請隨機從正整數 1-42當中隨機抽出 6個數字，不用排序，但不可重複。&lt;/p&gt;&#xA;&lt;h1 id=&#34;解法&#34;&gt;解法&lt;/h1&gt;&#xA;&lt;p&gt;樂透這個題目主要可以練習的有三個地方，隨機、迴圈，還有就是如何確保數字不重複。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;以 Java 來說，隨機就是使用 &lt;code&gt;java.lang.Math&lt;/code&gt; 類別裡的靜態方法 &lt;code&gt;random()&lt;/code&gt;，但要注意&lt;code&gt;Math.random()&lt;/code&gt; 之後產生的是大於等於 0、小於 1，也就是 &lt;code&gt;0 &amp;lt;= Math.random() &amp;lt; 1&lt;/code&gt; 的 &lt;code&gt;double&lt;/code&gt; 型態浮點常數。&lt;br&gt;&#xA;因此，以這題來說，還要記得利用 &lt;code&gt;(int)&lt;/code&gt; 轉換型態成整數型態的常數。&lt;br&gt;&#xA;另外，若不放心浮點數轉換為整數後的值，可以利用一樣是 &lt;code&gt;Math&lt;/code&gt; 類別裡的靜態方法 &lt;code&gt;floor()&lt;/code&gt; 或 &lt;code&gt;ceiling()&lt;/code&gt; 來取無條件進位或無條件捨去後的整數值。&#xA;而產生指定範圍內的亂數的公式為 &lt;code&gt;Math.random() * 範圍個數 + 初值&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;然後因為已經確定要抽出的數目，所以可以使用元素個數不能變動的陣列，當然也可以用可以變動個數的 &lt;code&gt;Collection&lt;/code&gt; 或其子介面去解決。關鍵就在於不可重複。&lt;/p&gt;&#xA;&lt;p&gt;這篇只討論陣列的解法。&lt;/p&gt;&#xA;&lt;h2 id=&#34;暴力解重複檢查&#34;&gt;暴力解：重複檢查&lt;/h2&gt;&#xA;&lt;p&gt;最簡單的寫法肯定就是暴力解：每抽出一個數字就存到結果陣列，然後每抽一次，就跟陣列裡每個數字都比對一次，一有重複就重抽。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;// 設定存儲樂透數字陣列&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;[]&lt;/span&gt; randomArray &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;[&lt;/span&gt;6&lt;span style=&#34;color:#ff79c6&#34;&gt;]&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;// 執行抽取樂透數字的動作 6次&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt; randomArray.&lt;span style=&#34;color:#50fa7b&#34;&gt;length&lt;/span&gt;; i&lt;span style=&#34;color:#ff79c6&#34;&gt;++&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#6272a4&#34;&gt;// 先將亂數出來的數字存入陣列第 i個位置&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     randomArray&lt;span style=&#34;color:#ff79c6&#34;&gt;[&lt;/span&gt;i&lt;span style=&#34;color:#ff79c6&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt;)(Math.&lt;span style=&#34;color:#50fa7b&#34;&gt;random&lt;/span&gt;() &lt;span style=&#34;color:#ff79c6&#34;&gt;*&lt;/span&gt; 42) &lt;span style=&#34;color:#ff79c6&#34;&gt;+&lt;/span&gt; 1;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#6272a4&#34;&gt;// 接著執行檢查迴圈&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt; j &lt;span style=&#34;color:#ff79c6&#34;&gt;=&lt;/span&gt; 0; j &lt;span style=&#34;color:#ff79c6&#34;&gt;&amp;lt;&lt;/span&gt; i; j&lt;span style=&#34;color:#ff79c6&#34;&gt;++&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#6272a4&#34;&gt;// 輪流跟陣列中目前存在的其他元素比對&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; (randomArray&lt;span style=&#34;color:#ff79c6&#34;&gt;[&lt;/span&gt;i&lt;span style=&#34;color:#ff79c6&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#ff79c6&#34;&gt;==&lt;/span&gt; randomArray&lt;span style=&#34;color:#ff79c6&#34;&gt;[&lt;/span&gt;j&lt;span style=&#34;color:#ff79c6&#34;&gt;]&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#6272a4&#34;&gt;// 如果有找到重複數字，就將計數器 i減 1，然後重抽&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            i&lt;span style=&#34;color:#ff79c6&#34;&gt;--&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#6272a4&#34;&gt;// 注意這邊 break是跳出 if外面一層的 for迴圈&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#ff79c6&#34;&gt;break&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#6272a4&#34;&gt;// 印出樂透數字陣列中的數字，列印陣列也要用迴圈，這邊是用新版寫法&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#8be9fd&#34;&gt;int&lt;/span&gt; num : randomArray) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    System.&lt;span style=&#34;color:#50fa7b&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#50fa7b&#34;&gt;print&lt;/span&gt;(num &lt;span style=&#34;color:#ff79c6&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;fisher-yates-shuffle&#34;&gt;Fisher-Yates shuffle&lt;/h2&gt;&#xA;&lt;p&gt;能解決問題的方法就是好方法，但暴力解有一個問題，因為要檢查已存入陣列的其他元素，所以抽到越後面就要檢查越多次，現在只有 42 個數字抽 6 個，萬一是從一百億中抽一百萬個不重複數字，那該檢查多久？&lt;/p&gt;</description>
    </item>
    <item>
      <title>Markdown 語法</title>
      <link>https://blog.idontwannarock.dev/2017/10/markdown_syntax/</link>
      <pubDate>Sun, 22 Oct 2017 15:42:04 +0800</pubDate>
      <guid>https://blog.idontwannarock.dev/2017/10/markdown_syntax/</guid>
      <description>&lt;h1 id=&#34;markdown-特色&#34;&gt;Markdown 特色&lt;/h1&gt;&#xA;&lt;h2 id=&#34;易編寫&#34;&gt;易編寫&lt;/h2&gt;&#xA;&lt;p&gt;相對於 HTML 需要注意各種 tag、屬性、特殊字元，Markdown 是更容易編寫的方式，雖然無法像 HTML 那樣可以直接透過各種屬性，甚至 CSS 來達到各種效果，但純粹以書寫來說，Markdown 的功能已經相當夠用。&lt;/p&gt;&#xA;&lt;h2 id=&#34;轉換-html&#34;&gt;轉換 HTML&lt;/h2&gt;&#xA;&lt;p&gt;不過如果有需要的話，Markdown 可以用各種方式轉換成 HTML，以方便我們發布成網頁或部落格文章，網路上有相當多的程式可以達到這點；相對之下，從 HTML 轉換回 Markdown 就沒這麼方便了，主要原因就是 HTML 有相當多屬性等並不被 Markdown 支援，所以有轉換回 Markdown 的困難。&lt;/p&gt;&#xA;&lt;p&gt;但還是有補救的辦法，在編寫 Markdown 文件的時候，其實還是可以使用 HTML 語法的，我使用過的轉換器都可以讀取 HTML 語法，並正常顯示以及轉換，所以真的有什麼 Markdown 找不到的 HTML 功能，就直接寫 HTML 吧！當然這就需要對 HTML 語法有更多認識了。&lt;/p&gt;&#xA;&lt;h2 id=&#34;編寫視覺&#34;&gt;編寫／視覺&lt;/h2&gt;&#xA;&lt;p&gt;跟 HTML 一樣，在編寫 Markdown 的時候呈現的畫面，跟實際呈現的畫面其實是不一樣的。&lt;/p&gt;&#xA;&lt;p&gt;例如我們編寫 Markdown 如下：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-md&#34; data-lang=&#34;md&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ff79c6&#34;&gt;-&lt;/span&gt; ***This*** is a [&lt;span style=&#34;color:#ff79c6&#34;&gt;sample&lt;/span&gt;](&lt;span style=&#34;color:#50fa7b&#34;&gt;http://example.com/ &amp;#34;example.com&amp;#34;&lt;/span&gt;).&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;實際呈現的畫面其實是這樣的：&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;em&gt;&lt;strong&gt;This&lt;/strong&gt;&lt;/em&gt; is a &lt;a href=&#34;http://example.com/&#34; title=&#34;example.com&#34;&gt;sample&lt;/a&gt;.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;所以在編寫 Markdown 的時候，最好找個可以隨時觀看實際畫面的編輯器來確認實際畫面。&lt;/p&gt;&#xA;&lt;h1 id=&#34;區塊元素&#34;&gt;區塊元素&lt;/h1&gt;&#xA;&lt;h2 id=&#34;換行&#34;&gt;換行&lt;/h2&gt;&#xA;&lt;p&gt;原則上按 Enter 鍵就是換行。&lt;/p&gt;</description>
    </item>
    <item>
      <title>整數溢位 Integer Overflow</title>
      <link>https://blog.idontwannarock.dev/2017/10/integer_overflow/</link>
      <pubDate>Sun, 01 Oct 2017 07:04:47 +0800</pubDate>
      <guid>https://blog.idontwannarock.dev/2017/10/integer_overflow/</guid>
      <description>&lt;p&gt;這是我查到一些資料後的理解，希望能多一點對整數溢位後為何會正負循環的了解。&lt;/p&gt;&#xA;&lt;h1 id=&#34;數字系統&#34;&gt;數字系統&lt;/h1&gt;&#xA;&lt;p&gt;首先要了解的是數字系統，因為一般電腦是採用二進制 (Binary) 來作數字計算，而不是我們習慣的十進制 (Decimal)。&lt;/p&gt;&#xA;&lt;p&gt;我們一般人都是用十進制，十進制就是用 &lt;code&gt;0、1、2、3、4、5、6、7、8、9&lt;/code&gt; 十個數字來表達，一個位數就有十種狀態，從 0 開始往上累積，超過 9 就進一位。&lt;/p&gt;&#xA;&lt;p&gt;而二進制是什麼呢？二進制就是用 &lt;code&gt;0、1&lt;/code&gt; 兩個數字來表達，一個位數就只有兩種狀態表達，從 0 開始往上累積，超過 1 就進一位。&lt;/p&gt;&#xA;&lt;p&gt;以十進制來說，&lt;code&gt;13&lt;/code&gt; 這個數字其實應該寫成 &lt;code&gt;1*10^1 + 3*10^0&lt;/code&gt; 這樣。&lt;code&gt;10^0&lt;/code&gt; 是 &lt;code&gt;1&lt;/code&gt;，也就是代表個位數，乘以幾就是這個位數累積到幾，超過 &lt;code&gt;9&lt;/code&gt; 就進一位到 &lt;code&gt;10^1&lt;/code&gt; 這一位，也就是十位數；再累積超過 &lt;code&gt;9&lt;/code&gt;，就進位到 &lt;code&gt;10^2&lt;/code&gt; 百位數，以此類推。&lt;/p&gt;&#xA;&lt;p&gt;那二進制怎麼表達呢？例如有一個二進制的數字長這樣 &lt;code&gt;1101&lt;/code&gt;，如同十進制，我們可以表達成 &lt;code&gt;1*2^3 + 1*2^2 + 0*2^1 + 1*2^0&lt;/code&gt;。這樣公式算完的答案其實就是十進制的 &lt;code&gt;13&lt;/code&gt;，大家可以算一下試試看。其實其他如八進制、十六進制也是相同原理，只不過超過十進制的進制系統，因為阿拉伯數字無法在單一位數表達 &lt;code&gt;10&lt;/code&gt; 以上的數字大小，所以會配合英文字母 &lt;code&gt;A、B、C、D&lt;/code&gt; 等等。&lt;/p&gt;&#xA;&lt;p&gt;另外複習一下國小（國中？）數學，小數點的部分，以我們常用的十進制來說，小數點後第一位是 &lt;code&gt;10^-1&lt;/code&gt;、第二位是 &lt;code&gt;10^-2&lt;/code&gt;，以此類推；相對的二進制也是一樣規則，小數點後第一位是 &lt;code&gt;2^-1&lt;/code&gt;、第二位是 &lt;code&gt;2^-2&lt;/code&gt; 這樣。&lt;/p&gt;&#xA;&lt;h1 id=&#34;電腦基本運算方式&#34;&gt;電腦基本運算方式&lt;/h1&gt;&#xA;&lt;p&gt;前面說到一般電腦是用二進制運算，這是什麼意思？&lt;/p&gt;&#xA;&lt;p&gt;舉個例子，今天假設一台電腦，我們拉了第一條電線在裡面，一條電線怎麼表達不同的狀態呢？對，就是通電，有通電是一種狀態，沒通電是一種狀態。當然比較實際的作法是透過電壓，高電壓是一種狀態，低電壓是一種狀態，這樣來表達兩種狀態。&lt;/p&gt;&#xA;&lt;p&gt;因此一條電線就能表達兩種狀態，剛好符合二進制只用 &lt;code&gt;0、1&lt;/code&gt; 兩個數字來表達所有數字的狀態，而這樣能表達兩種狀態（1 或 0）的一條電線就是 1 bit。順便講一下因為某些原因，8 bits 被規定為 1 byte。bit 就是我們常聽到的位元，byte 就是我們更常聽到的位元組。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
