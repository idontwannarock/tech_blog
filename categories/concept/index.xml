<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>concept on Howard Tech Note</title>
    <link>https://idontwannarock.github.io/tech_blog/categories/concept/</link>
    <description>Recent content in concept on Howard Tech Note</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This website by Howard Wang is licensed under a Creative Common Attribution-ShareAlike 4.0 International License.</copyright>
    <lastBuildDate>Tue, 21 Dec 2021 09:06:29 +0800</lastBuildDate><atom:link href="https://idontwannarock.github.io/tech_blog/categories/concept/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>HTTP/2 介紹</title>
      <link>https://idontwannarock.github.io/tech_blog/2021/12/http2/</link>
      <pubDate>Tue, 21 Dec 2021 09:06:29 +0800</pubDate>
      
      <guid>https://idontwannarock.github.io/tech_blog/2021/12/http2/</guid>
      <description>從 2015 年 RFC 7540 正式發表後，至今 HTTP/2 已經被絕大多數主流瀏覽器所支援，並且是正當紅的 gRPC 的基礎，在研究 gPRC 之前，先來釐清一下 HTTP/2 的概念
從遠古 HTTP/1.0 開始 HTTP 是定義在 OSI 模型第七層 Application Layer 網路協議，HTTP/1.0 採取先進先出 (first-in first-out, FIFO) 策略，每次請求/回應都是有序的，必須等到請求收到對應回應後，才能進行下一次請求
HTTP 在 Transport Layer 採用 TCP 連線來通訊，而 TCP 要在 client/server 之間建立連線，是靠著三向交握 (three-way handshake) 來完成；而傳輸完成要斷線時則要做四次握手 (four-way handshake)。如果還有 TLS，那握手的來回通訊次數 (round-trip time, RTT) 就更多次了
而在最初的 HTTP/1.0 的年代，硬體普遍效能都不高，為了提高系統的效率，所以 HTTP/1.0 規定 client/server 只能保持短暫的連線，所以 client 每次請求最少都要經過三向交握建立 TCP 連線，而 server 完成該請求的處理後也必須立刻進行四次握手斷開連線
這樣的作法節省了 server 端的效能，但這同樣也會造成一些其他效能上的問題，例如當網頁元素越來越多的時候，即使每個元素都不大，但 client/server 每個元素都還是要重新建立連線，不但費時，而且同樣會影響 client/server 的效能</description>
    </item>
    
    <item>
      <title>Spring Security 整合 RBAC</title>
      <link>https://idontwannarock.github.io/tech_blog/2019/05/spring_security_rbac/</link>
      <pubDate>Thu, 30 May 2019 15:33:07 +0800</pubDate>
      
      <guid>https://idontwannarock.github.io/tech_blog/2019/05/spring_security_rbac/</guid>
      <description>目前比較主流的 Role-based Access Control, RBAC 算是比較成熟且彈性的權限架構，若要在 Spring Security 實作 RBAC 並搭配 JWT 或 OAuth 2.0，大概要探討兩個問題
 是否值得為了減少查詢資料源的次數，而將角色或權限直接置入 JWT 或 Authorization Server 回傳的 token 是否採取 Spring Security 原生只使用最細粒度的權限來進行存取控制  關於第一個問題，目前的思考點大概就是考量系統的併發度跟使用者總數
如果需要高併發，那自然希望盡量減少查詢資料的次數或資料量，盡量避免同時大量消耗 DB 資源；相反的，如果不需要高併發，那每次驗證都重新取得角色及權限資料也沒關係
使用者數量的考量也是類似，如果每次查詢的成本太高，則盡量減少查詢的次數
而第二個問題，則是要考量實際的業務場景
如果角色跟權限很大量且複雜，或可能要考慮角色分層甚至使用者群組，或不同 Domain 有不同的權限邏輯，則可能用 Spring Security 原生方式會不敷使用，相對如果角色權限結構簡單，則直接使用原生方式可能成本較低
所以以下探討主要專注於使用 Spring Security 提供的自訂空間來實作較為複雜的存取控制
Spring Security 權限架構 首先要探討 Spring Security 原生提供的權限架構
 GrantedAuthority: 可以將每個 GrantedAuthority 想成是個別的 privilege，所以在 Spring Security 中，authority 就是 privilege 的概念 Role: 在 Spring Security 中為了保持彈性，Role 可以當作 Authority 也可以當作一組 Authority 的組合  Role as Authority: 直接把 Role 當成一種 Authority 的情況，就是將 Role 當作一個有 ROLE_ 前綴的字串，這種情況下 Role 跟 Authority 就只是語意上的差別 Role as Container: Role 可以包含一組 Authority，Spring Security 在這個概念上沒有提供太多指引說明，需要自行實作     Granted Authority Versus Role in Spring Security</description>
    </item>
    
    <item>
      <title>Github Flow 簡介</title>
      <link>https://idontwannarock.github.io/tech_blog/2019/05/github_flow_intro/</link>
      <pubDate>Wed, 29 May 2019 10:52:45 +0800</pubDate>
      
      <guid>https://idontwannarock.github.io/tech_blog/2019/05/github_flow_intro/</guid>
      <description>Understanding the GitHub flow
GitHub flow 只有一條原則：
 在 master 的任何 commit 永遠都是可以被部署的
 所以所有要做開發的 branch 都直接從 master 分支出去，不論是 feature 或 fix
開發的每個 commit 都要寫清楚 message，註明該 commit 做的變動以及理由等等
當開發到一定階段後，就可以對 master 開 Pull Request, PR，這在 GitHub flow 很重要
如果是用 Fork &amp;amp; Pull 模式，PR 就是用來通知專案維護者關於你希望他們考慮的變更；如果是用 Shared Repository 模式，則 PR 就像是用來開一個討論空間，在 merge 到 master 之前來做 code review 或針對特定變更的討論
 Fork &amp;amp; Pull 模式就是需要先 fork 後再 pull 到本機做開發，完成並 push 後，開 PR 要求合併到主專案
Shared Repository 模式則是直接可以對主專案開 branch 做開發</description>
    </item>
    
    <item>
      <title>AOP 及 Spring AOP 簡述</title>
      <link>https://idontwannarock.github.io/tech_blog/2018/04/aop_and_spring_aop_basic/</link>
      <pubDate>Tue, 10 Apr 2018 13:22:52 +0800</pubDate>
      
      <guid>https://idontwannarock.github.io/tech_blog/2018/04/aop_and_spring_aop_basic/</guid>
      <description>這篇文章是初學的時候撰寫的，其中一些觀念並不正確，步驟也可能因為更新或觀念問題而不適用或者多餘，此篇文章僅為留做紀錄
  AOP(Aspect-Oriented Programming) 是一種基於 OOP(Object-Oriented Programming) 的改進 AOP 是基於動態代理 (Dynamic Proxy) 這種 design pattern AOP 主要的設計對象是切面 (Aspect)，而切面是用來模組化橫切關注點 (Cross-Cutting Concern) 切面需要定義公共功能，但可以明確定義功能在哪裡或以什麼方式應用，而不必修改受影響的類別。如此切面關注點就可以被模組化到特殊的類別 (切面) 裡面  優點  交易相關的邏輯位於同一位置，便於維護與升級 業務邏輯更簡潔，只包含核心業務代碼  術語及概念  Cross-Cutting Concern 橫切關注點：橫跨應用系統多個流程、模組的功能，例如日誌 (Logging)、安全 (Security) 檢查、交易 (Transaction) 等動作，在許多流程的多個位置都需要執行，這種動作就被稱為橫切關注點 Aspect 切面：橫切關注點被模組化後的一種特殊物件；還未模組化前是橫切關注點，抽取後成為一組一組的切面；另一方面來說代理會將一個一個切面重組為橫切關注點 Advice 通知：切面必須要完成的工作或行為，也就是切面的實作內容。切面裡面的各個方法即是一個、一個的通知 Target 目標：被通知的物件，也就是要被橫切的業務邏輯類別 Proxy 代理：向目標物件通知之後創建的對象。容器會建立一個代理，依照設定去縫合 (weave) 切面到應用程式中 JoinPoint 連接點：程序執行的某個特定位置或時機。例如某個類別的某個方法呼叫前、呼叫後、拋出異常後等等。  連接點由兩個因素決定：以方法表示的程式執行點、相對執行點表示的方位。例如 A 類別的 a() 方法執行前的 JoinPoint 連接點決定要素為：執行點 A#a()，方位為執行前的位置 概念類比：JoinPoint 連接點相當於資料庫的紀錄，切面相當於查詢條件   Pointcut 切面定義：每個類別都有多個連接點，類別的所有方法某種程度上都可以想成是 JoinPoint 連接點。AOP通過切面定位到特定的連接點  Spring AOP  AspectJ：Java 社群最完整、最廣為人知的 AOP 實作 Spring 2.</description>
    </item>
    
    <item>
      <title>Java 字串判定</title>
      <link>https://idontwannarock.github.io/tech_blog/2018/02/java_string_check/</link>
      <pubDate>Tue, 06 Feb 2018 14:09:25 +0800</pubDate>
      
      <guid>https://idontwannarock.github.io/tech_blog/2018/02/java_string_check/</guid>
      <description>因為開始做專題，開始要作資料檢查，首先會要碰到的就是最基本的檢查是否有輸入資料，也就是要檢查字串，記錄一下 Java 當中有關字串檢查的東西。
去除字串空白 這主要分兩個部分，一是去掉頭尾空白，一是去掉字串中間空白。
去掉頭尾空白就用 .trim()，去掉字串中間空白則可以用 .replaceAll(&amp;quot; &amp;quot;, &amp;quot;&amp;quot;) 的方式簡單完成。
但用 replaceAll() 方法有個小小的問題，就是萬一碰到的是空白字元，例如 \t、\r 這種就會有困難，所以必須要用正規表示式來去除，例如：
String str = &amp;#34;\t&amp;#34;; str.replaceAll(&amp;#34;\\s+&amp;#34;, &amp;#34;&amp;#34;); 檢查空值 接著如果要檢查字串是否有東西，要分成檢查兩種狀態，null 或空字串。
這邊有幾個方法檢查這個部分，但要注意它們實際功能上的區別。
.length == 0 這個是 Java 最原始的功能，基本上就是檢查字串長度是否為 0，回傳值型態為 boolean。
.isEmpty() 這個方法是 Java 6.0 之後推出用來取代 .length() == 0 的方法。isEmpty() 其實也是在檢查字串長度是否為 0，回傳值型態一樣為 boolean。
.equals(&amp;quot;&amp;quot;) 這個功能是用字串的比對功能，比對是否為空字串，結果應該會跟前兩個方法相同。
!= null 前面幾個方法都有一個共同的問題：萬一字串為 null，全都來不及檢查就會跳 NullPointerException。
所以必須要用這個方式檢查是否為 Null，再檢查是否為空字串，也就是要寫成類似下面這樣：
String string; if (string != null &amp;amp;&amp;amp; string.isEmpty()) { // things to do when string is neither null nor blank; } &amp;quot;&amp;quot;.</description>
    </item>
    
    <item>
      <title>Java 樂透抽取算法初探</title>
      <link>https://idontwannarock.github.io/tech_blog/2017/11/java_lottery_algorithm_basic/</link>
      <pubDate>Wed, 15 Nov 2017 14:26:17 +0800</pubDate>
      
      <guid>https://idontwannarock.github.io/tech_blog/2017/11/java_lottery_algorithm_basic/</guid>
      <description>因為做到這個經典練習演算法的題目，雖然是非常入門級的，也是讓我想了很久，覺得都做了這麼久，不記錄下來也是蠻可惜。
題目 請隨機從正整數 1-42當中隨機抽出 6個數字，不用排序，但不可重複。
解法 樂透這個題目主要可以練習的有三個地方，隨機、迴圈，還有就是如何確保數字不重複。
 以 Java 來說，隨機就是使用 java.lang.Math 類別裡的靜態方法 random()，但要注意Math.random() 之後產生的是大於等於 0、小於 1，也就是 0 &amp;lt;= Math.random() &amp;lt; 1 的 double 型態浮點常數。
因此，以這題來說，還要記得利用 (int) 轉換型態成整數型態的常數。
另外，若不放心浮點數轉換為整數後的值，可以利用一樣是 Math 類別裡的靜態方法 floor() 或 ceiling() 來取無條件進位或無條件捨去後的整數值。 而產生指定範圍內的亂數的公式為 Math.random() * 範圍個數 + 初值
 然後因為已經確定要抽出的數目，所以可以使用元素個數不能變動的陣列，當然也可以用可以變動個數的 Collection 或其子介面去解決。關鍵就在於不可重複。
這篇只討論陣列的解法。
暴力解：重複檢查 最簡單的寫法肯定就是暴力解：每抽出一個數字就存到結果陣列，然後每抽一次，就跟陣列裡每個數字都比對一次，一有重複就重抽。
// 設定存儲樂透數字陣列 int[] randomArray = new int[6]; // 執行抽取樂透數字的動作 6次 for (int i = 0; i &amp;lt; randomArray.length; i++) { // 先將亂數出來的數字存入陣列第 i個位置  randomArray[i] = (int)(Math.</description>
    </item>
    
    <item>
      <title>Markdown 語法</title>
      <link>https://idontwannarock.github.io/tech_blog/2017/10/markdown_syntax/</link>
      <pubDate>Sun, 22 Oct 2017 15:42:04 +0800</pubDate>
      
      <guid>https://idontwannarock.github.io/tech_blog/2017/10/markdown_syntax/</guid>
      <description>Markdown 特色 易編寫 相對於 HTML 需要注意各種 tag、屬性、特殊字元，Markdown 是更容易編寫的方式，雖然無法像 HTML 那樣可以直接透過各種屬性，甚至 CSS 來達到各種效果，但純粹以書寫來說，Markdown 的功能已經相當夠用。
轉換 HTML 不過如果有需要的話，Markdown 可以用各種方式轉換成 HTML，以方便我們發布成網頁或部落格文章，網路上有相當多的程式可以達到這點；相對之下，從 HTML 轉換回 Markdown 就沒這麼方便了，主要原因就是 HTML 有相當多屬性等並不被 Markdown 支援，所以有轉換回 Markdown 的困難。
但還是有補救的辦法，在編寫 Markdown 文件的時候，其實還是可以使用 HTML 語法的，我使用過的轉換器都可以讀取 HTML 語法，並正常顯示以及轉換，所以真的有什麼 Markdown 找不到的 HTML 功能，就直接寫 HTML 吧！當然這就需要對 HTML 語法有更多認識了。
編寫／視覺 跟 HTML 一樣，在編寫 Markdown 的時候呈現的畫面，跟實際呈現的畫面其實是不一樣的。
例如我們編寫 Markdown 如下：
- ***This*** is a [sample](http://example.com/ &amp;#34;example.com&amp;#34;). 實際呈現的畫面其實是這樣的：
  This is a sample.   所以在編寫 Markdown 的時候，最好找個可以隨時觀看實際畫面的編輯器來確認實際畫面。</description>
    </item>
    
    <item>
      <title>整數溢位 Integer Overflow</title>
      <link>https://idontwannarock.github.io/tech_blog/2017/10/integer_overflow/</link>
      <pubDate>Sun, 01 Oct 2017 07:04:47 +0800</pubDate>
      
      <guid>https://idontwannarock.github.io/tech_blog/2017/10/integer_overflow/</guid>
      <description>這是我查到一些資料後的理解，希望能多一點對整數溢位後為何會正負循環的了解。
數字系統 首先要了解的是數字系統，因為一般電腦是採用二進制 (Binary) 來作數字計算，而不是我們習慣的十進制 (Decimal)。
我們一般人都是用十進制，十進制就是用 0、1、2、3、4、5、6、7、8、9 十個數字來表達，一個位數就有十種狀態，從 0 開始往上累積，超過 9 就進一位。
而二進制是什麼呢？二進制就是用 0、1 兩個數字來表達，一個位數就只有兩種狀態表達，從 0 開始往上累積，超過 1 就進一位。
以十進制來說，13 這個數字其實應該寫成 1*10^1 + 3*10^0 這樣。10^0 是 1，也就是代表個位數，乘以幾就是這個位數累積到幾，超過 9 就進一位到 10^1 這一位，也就是十位數；再累積超過 9，就進位到 10^2 百位數，以此類推。
那二進制怎麼表達呢？例如有一個二進制的數字長這樣 1101，如同十進制，我們可以表達成 1*2^3 + 1*2^2 + 0*2^1 + 1*2^0。這樣公式算完的答案其實就是十進制的 13，大家可以算一下試試看。其實其他如八進制、十六進制也是相同原理，只不過超過十進制的進制系統，因為阿拉伯數字無法在單一位數表達 10 以上的數字大小，所以會配合英文字母 A、B、C、D 等等。
另外複習一下國小（國中？）數學，小數點的部分，以我們常用的十進制來說，小數點後第一位是 10^-1、第二位是 10^-2，以此類推；相對的二進制也是一樣規則，小數點後第一位是 2^-1、第二位是 2^-2 這樣。
電腦基本運算方式 前面說到一般電腦是用二進制運算，這是什麼意思？
舉個例子，今天假設一台電腦，我們拉了第一條電線在裡面，一條電線怎麼表達不同的狀態呢？對，就是通電，有通電是一種狀態，沒通電是一種狀態。當然比較實際的作法是透過電壓，高電壓是一種狀態，低電壓是一種狀態，這樣來表達兩種狀態。
因此一條電線就能表達兩種狀態，剛好符合二進制只用 0、1 兩個數字來表達所有數字的狀態，而這樣能表達兩種狀態（1 或 0）的一條電線就是 1 bit。順便講一下因為某些原因，8 bits 被規定為 1 byte。bit 就是我們常聽到的位元，byte 就是我們更常聽到的位元組。</description>
    </item>
    
  </channel>
</rss>
