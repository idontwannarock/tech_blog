<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>implementation on Howard Tech Note</title>
    <link>https://blog.idontwannarock.me/categories/implementation/</link>
    <description>Recent content in implementation on Howard Tech Note</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This website by Howard Wang is licensed under a Creative Common Attribution-ShareAlike 4.0 International License.</copyright>
    <lastBuildDate>Wed, 20 Sep 2023 09:37:21 +0800</lastBuildDate><atom:link href="https://blog.idontwannarock.me/categories/implementation/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Spring JPA Projection with Converter</title>
      <link>https://blog.idontwannarock.me/2023/09/spring_jpa_projection_converter/</link>
      <pubDate>Wed, 20 Sep 2023 09:37:21 +0800</pubDate>
      
      <guid>https://blog.idontwannarock.me/2023/09/spring_jpa_projection_converter/</guid>
      <description>Pre-requisite JDK 11+ Spring Boot 2+ 情境描述 使用 JPA 做單表查詢非常方便，但有時候因為效能考量，會出現 DB data type 與 Java data type 無法直接對應或需要做一些客製化調整
例如在保存狀態時，因為狀態通常有固定且少量的值，所以會考慮採用 int 而非 varchar 來保存，在存儲大小跟查詢效能上都較優
CREATE TABLE CHATROOM ( ... `STATUS` INT NOT NULL, ... ); 但在程式面都採用 Java 的 int 來操作狀態，可讀性相對較低，所以可能會考慮採用 enum 來操作，可讀性較佳且有 type check
public enum ChatroomStatus { CLOSED, ACTIVE } 設定 Converter 但 JPA 預設並不能將 Java enum 與 MySQL int 做 mapping，所以會需要提供 converter 讓 JPA 知道怎麼做轉換
首先需要調整 enum 如下
public enum ChatroomStatus { CLOSED(0), ACTIVE(1); private final int value; ChatroomStatus(int value) { this.</description>
    </item>
    
    <item>
      <title>Scoop 介紹及用法</title>
      <link>https://blog.idontwannarock.me/2023/06/scoop/</link>
      <pubDate>Tue, 20 Jun 2023 10:51:39 +0800</pubDate>
      
      <guid>https://blog.idontwannarock.me/2023/06/scoop/</guid>
      <description>Linux 有 apt, yum、MacOS 有 Homebrew、Windows 有 Chocolatey
但今天要介紹 Windows 環境的另外一個 command line 套件管理工具 Scoop
在 Windows 環境，比較有名的 command line 套件管理工具是 Chocolatey，但今天要介紹的 Scoop 有一項 Chocolatey 沒辦法做到的好處，就是可以切換 Path Environment Variable
安裝 Scoop 的安裝非常簡單，打開 非 Administrator (系統管理員) 的 Powershell，並輸入以下指令即可安裝
Set-ExecutionPolicy RemoteSigned -Scope CurrentUser irm get.scoop.sh | iex 使用 Scoop 既然是套件管理工具，那重要的工作就是安裝套件，而 Scoop 有支援什麼套件固然可以直接 Google 的到，但其實也不是沒有方式直接在 command line 搜尋
例如想安裝 7zip 壓縮工具，可以在 powershell 當中這樣搜尋
scoop search 7zip 應該會出現如下的結果
第一行說明代表這次結果是在本地的 bucket 當中搜尋到的，表格當中的 Name 就是套件名稱，之後所有操作都要輸入 Name 當中顯示的完整名稱，Source 就是指套件所在的 bucket</description>
    </item>
    
    <item>
      <title>Gradle &#43; Docker Multi-stage build</title>
      <link>https://blog.idontwannarock.me/2022/12/gradle_docker_multi_stage_build/</link>
      <pubDate>Thu, 15 Dec 2022 10:18:10 +0800</pubDate>
      
      <guid>https://blog.idontwannarock.me/2022/12/gradle_docker_multi_stage_build/</guid>
      <description>Java 專案整合 Docker multi-stage build 系列：
Maven + Docker Multi-stage build Gradle + Docker Multi-stage build 前一篇講過 Maven 配合 Docker multi-stage build 的優化概念跟實作，這篇順便來講一下 Gradle 的部分
Docker Multi-stage Build 前一篇已經介紹過建置 Java 專案配合 Docker multi-stage build 的優化概念，這邊就不再贅述，直接上 Dockerfile：
FROM gradle:7.6-alpine AS Cache WORKDIR /opt/app ENV GRADLE_USER_HOME /cache COPY build.gradle ./ RUN gradle --no-daemon dependencies --stacktrace FROM gradle:7.6-jdk11-alpine AS Builder WORKDIR /opt/app COPY --from=Cache /cache /home/gradle/.gradle COPY build.gradle settings.gradle ./ COPY src /opt/app/src RUN gradle --no-daemon build --stacktrace --offline FROM azul/zulu-openjdk-alpine:11-jre-headless WORKDIR /opt/app COPY --from=Builder /opt/app/build/libs/*.</description>
    </item>
    
    <item>
      <title>Maven &#43; Docker Multi-stage Build</title>
      <link>https://blog.idontwannarock.me/2022/12/maven_docker_multi_stage_build/</link>
      <pubDate>Wed, 14 Dec 2022 14:14:44 +0800</pubDate>
      
      <guid>https://blog.idontwannarock.me/2022/12/maven_docker_multi_stage_build/</guid>
      <description>Java 專案整合 Docker multi-stage build 系列：
Maven + Docker Multi-stage build Gradle + Docker Multi-stage build 現代常見的 CI/CD 流程經常會使用容器化 (containerized) 的方式來幫助建置環境及部署
以 Java + Maven 專案舉例，一個比較通用的 Dockerfile 可能長這樣：
FROM maven:3.8-openjdk-11 WORKDIR /opt/app COPY src/main/resources /opt/app/src/main/resources COPY src/main/java /opt/app/src/main/java COPY pom.xml . RUN mvn -B -e clean package EXPOSE 8080 ENTRYPOINT [&amp;#34;java&amp;#34;, &amp;#34;-jar&amp;#34;, &amp;#34;demo.jar&amp;#34;] 這個 Dockerfile 其實沒有問題，完全可以正常運行，但它使用上有一個地方不太方便，就是每次運行到 RUN mvn -B -e clean package 這行的時候，除非程式碼跟 pom.xml 都沒有變動，否則所有 dependencies 都會重新下載一遍，如果專案比較大型，那光下載 dependencies 可能就會要花很久的時間
Docker Multi-stage Build 於是就有人使出了 Docker multi-stage build 這招</description>
    </item>
    
    <item>
      <title>SpringFox to SpringDoc</title>
      <link>https://blog.idontwannarock.me/2022/12/springfox_to_springdoc/</link>
      <pubDate>Mon, 12 Dec 2022 09:24:17 +0800</pubDate>
      
      <guid>https://blog.idontwannarock.me/2022/12/springfox_to_springdoc/</guid>
      <description>以 Spring Boot 生態來說，比較主流的 documentation 方式應該就是 Swagger，以往應該多數人都是使用 SpringFox library，但近幾年也漸漸興起使用 SpringDoc，所以就做了一點筆記，紀錄要怎麼從 SpringFox 轉移到 SpringDoc
比較 這兩者同樣都有實作 OpenAPI 3.0，為什麼我們需要從 SpringFox 轉移使用 SpringDoc？
springfox-boot-starter 包含許多 Spring 的 transitive dependencies；springdoc-openapi-ui 則是 standalone 的 library，並沒有跟 Spring 的依賴 springfox-boot-starter 需要額外 dependency 才有 Swagger UI 的呈現；springdoc-openapi-ui 則已經內含 Swagger UI SpringDoc 在一些細節功能上更強大，例如提供陣列參數更好的 UI 做輸入 最重要的一點，SpringFox 幾乎已經不再更新；而 SpringDoc 還有在常態維護，因此也能跟較新版本的 Spring 有更好的整合，也能更即時的修正 bug 升級步驟 相當簡單，參考 官方文件 即可
因為都是實作 OpenAPI，就算 SpringFox 有實作 2.0 版，但跟 3.0 其實差異也不大
主要就是改一下 dependency，然後 annotation 調整一下，其他幾乎沒有不同
注意事項 Spring Security 若有整合 Spring Security，則可以在 controller 透過加註 @AuthenticationPrincipal 註解注入驗證過的 principal 物件，但這個物件不需要呈現在 Swagger 上</description>
    </item>
    
    <item>
      <title>Spring Boot 整合 Quartz 集群執行預設及動態排程</title>
      <link>https://blog.idontwannarock.me/2022/11/quartz-cluster-fixed-and-dynamic-trigger-spring-boot-integration/</link>
      <pubDate>Tue, 15 Nov 2022 16:54:13 +0800</pubDate>
      
      <guid>https://blog.idontwannarock.me/2022/11/quartz-cluster-fixed-and-dynamic-trigger-spring-boot-integration/</guid>
      <description>Quartz 系列：
Quartz 介紹 Spring Boot 整合 Quartz 集群執行預設及動態排程 Quartz Misfire Handling Instruction Spring Boot 官方本身就有 spring-boot-starter-quartz 來提供 Quartz 整合，所以在 Spring Boot 當中使用基本 Quartz 功能已經非常簡單
至於動態產生排程，網路上也很多教學，只是大多是採用 API 呼叫的方式去動態產生、運行、暫停、刪除排程等功能，而幾乎沒看到利用預設排程定時從 database 取得動態排程設定，並動態產生或移除排程的功能
接下來探討如何在 Spring Boot 整合 Quartz 的框架中實作以上需求，來達成依照自訂動態排程來發通知的需求
以下討論採用 Spring Boot 2.7.5 及 Quartz 2.3.2 版本並搭配 MySQL 做持久化
Database Schema 首先需要在 MySQL 內建立相關的 schema，可以利用官方提供的這個 script 來建立，並額外依照以下 sql 建立動態通知排程的 table：
create table if not exist NOTIFICATION_SCHEDULE ( ID int auto_increment primary key, CRON varchar(100) not null comment &amp;#39;Quartz type cron&amp;#39;, TIMEZONE varchar(64) default &amp;#39;Asia/Taipei&amp;#39; null, TEMPLATE_ID int not null, IS_ONLINE tinyint(1) default 1 null, IS_DELETED tinyint(1) default 0 null, CREATE_TIME datetime default CURRENT_TIMESTAMP null, UPDATE_TIME datetime null on update CURRENT_TIMESTAMP ) comment &amp;#39;紀錄通知排程資訊&amp;#39;; Dependency 接著在 pom 檔引用以下依賴：</description>
    </item>
    
    <item>
      <title>Spring Boot 後端實作 XSS 防範</title>
      <link>https://blog.idontwannarock.me/2022/11/xss_prevention_spring_boot/</link>
      <pubDate>Tue, 01 Nov 2022 15:28:32 +0800</pubDate>
      
      <guid>https://blog.idontwannarock.me/2022/11/xss_prevention_spring_boot/</guid>
      <description>XSS 系列：
XSS 防範簡介 Spring Boot 後端實作 XSS 防範 身為一個 Java 後端工程師，今天要來討論如何在 Spring Boot 的後端專案進行 general 的 XSS 防範。
請還是注意，general 的手段並不能很良好的防範 XSS 攻擊，而只是提供一個基本程度的防範。
CSP Header 如果專案有整合 Spring Security，Spring Security 原生就已經預設在 response header 中加入 X-XSS-Protection: 1; mode=block，但因為 CSP 需要自行設定資源允許的來源，所以 Spring Security 並沒有預設，需要在 SecurityFilterChain 當中設定，舉例如下：
@Bean SecurityFilterChain filterChain(HttpSecurity httpSecurity) throws Exception { httpSecurity.headers().contentSecurityPolicy(&amp;#34;script-src &amp;#39;self&amp;#39;&amp;#34;); ... } 如此就會在 response header 中加入 Content-Security-Policy: script-src &#39;self&#39;。
Output Encoding 再來，後端也可以對接收到或回傳的資料做 escape，例如採取將內容都做 escape，將符號都轉換成 HTML Entities 的方式。
首先可以加入 Apache Commons Text dependency，有現成的方法可以處理文字中符號轉換的部分：</description>
    </item>
    
    <item>
      <title>ProtoBuf FlatBuf Benchmark in Java</title>
      <link>https://blog.idontwannarock.me/2022/01/protobuf_flatbuf_java/</link>
      <pubDate>Tue, 04 Jan 2022 15:36:17 +0800</pubDate>
      
      <guid>https://blog.idontwannarock.me/2022/01/protobuf_flatbuf_java/</guid>
      <description>繼續之前研究的 gRPC，除了 HTTP/2 以外，另外一個支柱就是 Protocol Buffers (ProtoBuf)
ProtoBuf 是一種二進制的序列化資料格式，透過介面描述語言 (Interface description language, IDL) 來描述資料結構，再利用工具依據 IDL 產生程式碼，這些程式碼可以用來生成或解析代表這些資料結構的位元組流
ProtoBuf 是 Google 原本用來內部使用的資料格式，但現在已開源，加上被 gRPC 原生支援，現在已經是重要的序列化 library
Google 官方支援了許多語言的工具用來轉換 IDL 為代碼，但其中很不巧的不包含我目前工作上避不開的 Lua 或 TypeScript，所以我又另外找到同樣也是 Google 推出的 FlatBuffers (FlatBuf)，同樣也是二進制的序列化 library，但官方支援的語系就很多了，正好也包括 Lua 及 TypeScript
雖然 Google 官方已經在努力讓 FlatBuf 也被 gRPC 支援，但目前官方文件上還只有 C++ 的版本，並沒有我日常使用的語言
不過沒關係，我工作上的專案目前並不是一定要使用 gRPC，我完全可以利用其他傳輸協定例如 HTTP, WebSocket 或甚至 Socket 來傳輸資料，我只需要一種能夠讓各語系通用的資料格式，並且盡可能有官方長期支援即可
Benchmark 方法 雖然剛好 FlatBuf 都符合我的需求，但 FlatBuf 使用的人似乎還不多，雖然官方文件上說 Facebook 已經將 FlatBuf 使用在 Android App 上，不過總是沒有自己親身試驗來的準，也一併試驗開發的困難度
所以乾脆來做 ProtoBuf 跟 FlatBuf 的 benchmark 來比較一下各自序列化的速度以及記憶體大致用量</description>
    </item>
    
    <item>
      <title>在 Batch Script 壓縮檔案</title>
      <link>https://blog.idontwannarock.me/2021/12/zip_in_batch_script/</link>
      <pubDate>Thu, 16 Dec 2021 15:32:25 +0800</pubDate>
      
      <guid>https://blog.idontwannarock.me/2021/12/zip_in_batch_script/</guid>
      <description>因為目前公司沒有專職 SRE 或 DevOps 幫忙做 CI/CD，身為小小後端工程師只好自己想辦法，偏偏目前用到的 tech stack 包括 .net framework，所以必須跟 Windows 環境的 batch file 打交道來替代習慣的 shell 檔，其中有個步驟必須要壓縮/解壓縮資料夾
Tar 研究了一下，很興奮的發現 tar 在 command prompt 跟 powershell 都可以用，那代表我在 batch 檔裡面使用沒問題ＲＲＲ
所以可以這樣用
:: zip tar -cvzf &amp;#34;path and name to archive.tar&amp;#34; &amp;#34;path to folder to compress&amp;#34; :: unzip tar -xvzf &amp;#34;path and name to archive.tar&amp;#34; Microsoft.Powershell.Archive Module 很可惜，這個方法有一個小小的問題
tar 基本上是從 Windows 10 或 Windows Server 2019 才開始支援，很不巧，我手上有個環境是 Windows Server 2016&amp;hellip;
基於可以用原生就絕不多安裝東西的自虐原則，好險又找到了另一個方法，powershell 有個 archive 的模組可以用！</description>
    </item>
    
    <item>
      <title>Spring Boot 實作 API 版本控制</title>
      <link>https://blog.idontwannarock.me/2019/09/spring_api_version_with_swagger_security/</link>
      <pubDate>Thu, 19 Sep 2019 15:53:36 +0800</pubDate>
      
      <guid>https://blog.idontwannarock.me/2019/09/spring_api_version_with_swagger_security/</guid>
      <description>本文目的是為了探討在 Spring Boot Web 專案中，實作 API 版本控制，並兼容 Swagger 及 Spring Security 的解決方式
需要有 Spring Boot、Spring MVC、Spring Security 及 Swagger 的基礎概念會比較好理解
API 版本控制 常見的 API 版本控制方式有三種: URI, header, content-type
考量到 RESTful API 其中的一個好處是方便快取，使用 header 跟 content-type 的方式則可能無法正確的快取以及達成 idempotent，所以我個人採用的是在 URI 中加入版本號的方式
再來因為有時候面對的專案有數量眾多的 handler，導致每次修改版本號都要手動修改每一支 handler 對應的 uri，這樣既麻煩又不潮，所以一定要研究一下怎麼在 Spring Boot 專案中利用註解的方式自動幫 handler 對應的 uri 自動插入版本號
Tech Stack 專案採用的是 Spring Boot 2.0 架構，Java 1.8 版本
有關 Maven 依賴如下:
org.springframework.boot:spring-boot-starter-web:2.1.x org.springframework.boot:spring-boot-starter-security:2.1.x io.springfox:springfox-swagger2:2.9.2 io.springfox:springfox-swagger-ui:2.9.2 這邊強調要採用 Spring Boot 主要是因為想要利用 Spring Boot auto configuration 的功能，也因為想要利用這個功能，所以過程才會這麼曲折&amp;hellip;</description>
    </item>
    
  </channel>
</rss>
